[PMU]
@ = 0x0FD8D0000, 0x00010000

PMU_PWR_CON0 = 0x0000 ; PMU power control 0 register
> 14, 1, POWER_OFF_IO_ENA ; Enable VCCIO enter low power mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 13, 1, BIU_AUTO_PMU1 ; When perform idle operation, BIU_PMU1 corresponding clock can be opened or gated automatically.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PMU1_BUS_IDLE_SFTENA ; Enable sending idle request to BIU_PMU1 by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PMU1_BUS_IDLE_ENA ; Enable sending idle request to BIU_PMU1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PMU1_MEMPWR_GATE_SFTENA ; Enable power down PD_PMU1's memory by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PMU1_PWR_GATE_SFTENA ; Enable power down PD_PMU1 by software.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PMU1_PWR_GATE_ENA ; Enable power down PD_PMU1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, OSC_DIS_BYPASS ; Bypass disable oscillator in power mode 0 procedure. If asserted, the oscillator cannot be disabled by FSM during power mode 0 procedure.
= 0, DISABLE
= 1, ENABLE

> 6, 1, FREQ_SWITCH_BYPASS ; Bypass frequency switch stability in power mode 0 procedure. If asserted, clk_pmu cannot be switched to 32KHz clock source during power mode 0 procedure.
= 0, DISABLE
= 1, ENABLE

> 5, 1, RESET_BYPASS ; Bypass wake up reset clear stability in power mode 0 procedure. If asserted, the FSM will enter next state not wait for reset counter, and chip will not be reset.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PMIC_BYPASS ; Bypass waiting for PMIC stability in power mode 0 procedure. If asserted, the FSM will enter next state not wait until PMIC is stable.
= 0, DISABLE
= 1, ENABLE

> 3, 1, WAKEUP_BYPASS ; Bypass waiting for wake up interrupt in power mode 0 procedure. If asserted, the FSM will exit sleep state without waiting for wake up source.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PMU1_BUS_BYPASS ; Bypass BIU_PMU1 idle flow in power mode 0 procedure.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PMU1_PWR_BYPASS ; Bypass PD_PMU1 power gating flow in power mode 0 procedure. If asserted, PD_PMU1 is not power down or power up during power mode 0 procedure.
= 0, DISABLE
= 1, ENABLE

> 0, 1, POWERMODE0_EN ; Power mode 0 enable. When controller enters power mode 0 procedure, this bit is automatically cleared.
= 0, DISABLE
= 1, ENABLE

PMU_WAKEUP_INT_CON_P0 = 0x0008 ; PMU wake up interrupt control register for power mode 0
> 0, 1, WAKEUP_INT_EN ; Enable GPIO interrupt as wake up source to exit power mode 0 procedure.
= 0, DISABLE
= 1, ENABLE

PMU_WAKEUP_INT_STS_P0 = 0x000C ; PMU wake up interrupt status register for power mode 0
> 0, 1, WAKEUP_INT_ST, RO ; Power mode 0 wake up source status.
= 0, INACTIVE
= 1, ACTIVE

PMU_PMIC_STABLE_CNT_P0 = 0x0010 ; PMIC stable count register for power mode 0
> 0, 20, PMIC_STABLE_CNT ; PMIC stable count for power mode 0 procedure. Number of clk_pmu used by counter logic.

PMU_WAKEUP_RST_CLR_CNT_P0 = 0x0014 ; Wake up reset clear count register for power mode 0
> 0, 20, WAKEUP_RST_CLR_CNT ; Wake up reset clear count for power mode 0 procedure. Number of clk_pmu used by counter logic.

PMU_OSC_STABLE_CNT_P0 = 0x0018 ; Oscillator stable count register for power mode 0
> 0, 20, OSC_STABLE_CNT ; Oscillator stable count for power mode 0 procedure. Number of clk_pmu used by counter logic.

PMU_PMU1_PWR_CHAIN_STABLE_CON = 0x001C ; PD_PMU1 power chain stable control register
> 9, 5, PMU1_PWR_DWN_STABLE_CNT ; Stable count for PD_PMU1 power down flow. Number of clk_pmu used by counter logic.

> 8, 1, PMU1_PWR_DWN_STABLE_EN ; Enable stable counter between power chains for PD_PMU1 power down flow.
= 0, DISABLE
= 1, ENABLE

> 1, 5, PMU1_PWR_UP_STABLE_CNT ; Stable count for PD_PMU1 power up flow. Number of clk_pmu used by counter logic.

> 0, 1, PMU1_PWR_UP_STABLE_EN ; Enable stable counter between power chains for PD_PMU1 power up flow.
= 0, DISABLE
= 1, ENABLE

PMU_DDR_RET_CON0_P0 = 0x0020 ; DDR retention control register 0 for power mode 0
> 12, 4, DDRIO_RSTIOV_EXIT_ENA ; Enable DDR exits retention mode through RST_IOV by hardware in power mode 0 procedure. Bit[12] used for DDR channel 0. Bit[13] used for DDR channel 1. Bit[14] used for DDR channel 2. Bit[15] used for DDR channel 3.
= 0, DISABLE
= 1, ENABLE

> 8, 4, DDRIO_RETON_EXIT_ENA ; Enable DDR exits retention mode through RETON/RETOFF by hardware in power mode 0 procedure. Bit[8] used for DDR channel 0. Bit[9] used for DDR channel 1. Bit[10] used for DDR channel 2. Bit[11] used for DDR channel 3.
= 0, DISABLE
= 1, ENABLE

> 4, 4, DDRIO_RSTIOV_ENTER_ENA ; Enable DDR enters retention mode through RST_IOV by hardware in power mode 0 procedure. Bit[4] used for DDR channel 0. Bit[5] used for DDR channel 1. Bit[6] used for DDR channel 2. Bit[7] used for DDR channel 3.
= 0, DISABLE
= 1, ENABLE

> 0, 4, DDRIO_RETON_ENTER_ENA ; Enable DDR enters retention mode through RETON/RETOFF by hardware in power mode 0 procedure. Bit[0] used for DDR channel 0. Bit[1] used for DDR channel 1. Bit[2] used for DDR channel 2. Bit[3] used for DDR channel 3.
= 0, DISABLE
= 1, ENABLE

PMU_DDR_RET_CON1_P0 = 0x0024 ; DDR retention control register 1 for power mode 0
> 12, 4, DDRIO_RSTIOV_EXIT_SFTENA ; Enable DDR exits retention mode through RST_IOV by software. Bit[12] used for DDR channel 0. Bit[13] used for DDR channel 1. Bit[14] used for DDR channel 2. Bit[15] used for DDR channel 3.
= 0, DISABLE
= 1, ENABLE

> 8, 4, DDRIO_RETON_EXIT_SFTENA ; Enable DDR exits retention mode through RETON/RETOFF by software. Bit[8] used for DDR channel 0. Bit[9] used for DDR channel 1. Bit[10] used for DDR channel 2. Bit[11] used for DDR channel 3.
= 0, DISABLE
= 1, ENABLE

> 4, 4, DDRIO_RSTIOV_ENTER_SFTENA ; Enable DDR enters retention mode through RST_IOV by software. Bit[4] used for DDR channel 0. Bit[5] used for DDR channel 1. Bit[6] used for DDR channel 2. Bit[7] used for DDR channel 3.
= 0, DISABLE
= 1, ENABLE

> 0, 4, DDRIO_RETON_ENTER_SFTENA ; Enable DDR enters retention mode through RETON/RETOFF by software. Bit[0] used for DDR channel 0. Bit[1] used for DDR channel 1. Bit[2] used for DDR channel 2. Bit[3] used for DDR channel 3.
= 0, DISABLE
= 1, ENABLE

PMU_INFO_TX_CON = 0x0030 ; PMU debug information transmit control register
> 8, 1, INFO_TX_EN ; Enable PMU debug information transition.
= 0, DISABLE
= 1, ENABLE

> 0, 8, INFO_TX_INTV_TIME ; The interval time between the bytes of PMU debug information.

PMU_VERSION = 0x4000 ; PMU version register
> 0, 32, VERSION, RO

PMU_PWR_CON1 = 0x4004 ; PMU power control 1 register
> 12, 1, WFI_BYPASS ; Bypass WFI in power mode 1 procedure. If asserted, PMU FSM does not need to wait for CPU standbywfi state before entering low power flow.
= 0, DISABLE
= 1, ENABLE

> 9, 3, CORE_BYPASS ; Bypass core low power flow in power mode 1 procedure. Bit[9] used to bypass BIGCORE0 low power flow. Bit[10] used to bypass BIGCORE1 low power flow. Bit[11] used to bypass LITDSU low power flow.
= 0, DISABLE
= 1, ENABLE

> 8, 1, QCH_BYPASS ; Bypass power Q-Channel low power flow in power mode 1 procedure. If asserted, PMU_QCHANNEL_PWR_CON cannot take effect for power Q-Channel low power flow. If you want to execute power Q-Channel low power flow, you can program PMU_QCHANNEL_PWR_SFTCON through software flow.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CRU_BYPASS ; Bypass clock and reset low power flow in power mode 1 procedure. If asserted, PMU_CRU_PWR_CON cannot take effect for clock and reset low power flow. If you want to execute clock and reset low power flow, you can program PMU_CRU_PWR_SFTCON through software flow.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PWRGATE_BYPASS ; Bypass power gating flow in power mode 1 procedure. If asserted, PMU_PWR_GATE_CON0/1/2 cannot take effect for power gating flow. If you want to execute power gating flow, you can program PMU_PWR_GATE_SFTCON0/1/2 through software flow.
= 0, DISABLE
= 1, ENABLE

> 5, 1, DDR_BYPASS ; Bypass DDR low power flow in power mode 1 procedure. If asserted, PMU_DDR_CH0/1/2/3_PWR_CON cannot take effect for DDR low power flow. If you want to execute DDR low power flow, you can program PMU_DDR_CH0/1/2/3_PWR_SFTCON through software flow.
= 0, DISABLE
= 1, ENABLE

> 4, 1, BUS_BYPASS ; Bypass BIU idle request in power mode 1 procedure. If asserted, PMU_BIU_IDLE_CON0/1/2 cannot take effect for BIU idle request. If you want to execute BIU idle request, you can program PMU_BIU_IDLE_SFTCON0/1/2 through software flow.
= 0, DISABLE
= 1, ENABLE

> 1, 1, DSU_BYPASS ; Bypass DSU low power flow in power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 0, 1, POWERMODE1_EN ; Power mode 1 enable. When controller enters power mode 1 procedure. It is automatically cleared after PMU enters power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

PMU_GLB_POWER_STS = 0x4008 ; PMU global power status register
> 0, 4, POWER_STATE, RO ; PMU1 global power state.
= 0, NORMAL ; Normal state
= 1, CORE_LP ; Core low power state
= 2, CLUSTER_LP ; Cluster low power state
= 3, QCH_LP ; Q-Channel low power state
= 4, BUS_LP ; Bus low power state
= 5, DDR_LP ; DDR low power state
= 6, PG_LP ; Power gating low power state
= 7, CR_LP ; Clock and reset low power state
= 8, SLEEP ; Sleep state
= 9, CR_ACTIVE ; Clock and reset active state
= 10, PG_ACTIVE ; Power gating active state
= 11, DDR_ACTIVE ; DDR active state
= 12, BUS_ACTIVE ; Bus active state
= 13, QCH_ACTIVE ; Q-Channel active state
= 14, CLUSTER_ACTIVE ; Cluster active state
= 15, CORE_ACTIVE ; Core active state

PMU_INT_MASK_CON = 0x400C ; PMU interrupt mask control register
> 0, 1, GLB_INT_MASK ; Global interrupt mask during DSU sleep state.
= 0, UNMASKED ; Interrupt is not mask
= 1, MASKED ; Interrupt is mask

PMU_WAKEUP_INT_CON = 0x4010 ; PMU wake up interrupt control register
> 16, 1, WAKEUP_TIMEOUT_EN ; Enable PMU wake up timeout as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 15, 1, WAKEUP_SYS_INT_EN ; Enable system interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 14, 1, WAKEUP_TIMER_INT_EN ; Enable PMU_TIMER interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 13, 1, WAKEUP_VAD_INT_EN ; Enable VAD interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 12, 1, WAKEUP_UART0_INT_EN ; Enable UART0 interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 11, 1, WAKEUP_USB_INT_EN ; Enable USB detect interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 10, 1, WAKEUP_SDIO_INT_EN ; Enable SDIO interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 9, 1, WAKEUP_SDMMC_INT_EN ; Enable SDMMC detect interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 8, 1, WAKEUP_GPIO0_INT_EN ; Enable GPIO0 interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 7, 1, WAKEUP_CPU7_INT_EN ; Enable CPU7 interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 6, 1, WAKEUP_CPU6_INT_EN ; Enable CPU6 interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 5, 1, WAKEUP_CPU5_INT_EN ; Enable CPU5 interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 4, 1, WAKEUP_CPU4_INT_EN ; Enable CPU4 interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 3, 1, WAKEUP_CPU3_INT_EN ; Enable CPU3 interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 2, 1, WAKEUP_CPU2_INT_EN ; Enable CPU2 interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 1, 1, WAKEUP_CPU1_INT_EN ; Enable CPU1 interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

> 0, 1, WAKEUP_CPU0_INT_EN ; Enable CPU0 interrupt as wake up source to exit power mode 1 procedure.
= 0, DISABLE
= 1, ENABLE

PMU_WAKEUP_INT_STS = 0x4014 ; PMU wake up interrupt status register
> 16, 1, WAKEUP_TIMEOUT_ST, RO ; Wake up timeout as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 15, 1, WAKEUP_SYS_INT_ST, RO ; System interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 14, 1, WAKEUP_TIMER_INT_ST, RO ; PMU_TIMER interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 13, 1, WAKEUP_VAD_INT_ST, RO ; VAD interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 12, 1, WAKEUP_UART0_INT_ST, RO ; UART0 interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 11, 1, WAKEUP_USB_INT_ST, RO ; USB detect interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 10, 1, WAKEUP_SDIO_INT_ST, RO ; SDIO interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 9, 1, WAKEUP_SDMMC_INT_ST, RO ; SDMMC detect interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 8, 1, WAKEUP_GPIO0_INT_ST, RO ; GPIO0 interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 7, 1, WAKEUP_CPU7_INT_ST, RO ; CPU7 interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 6, 1, WAKEUP_CPU6_INT_ST, RO ; CPU6 interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 5, 1, WAKEUP_CPU5_INT_ST, RO ; CPU5 interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 4, 1, WAKEUP_CPU4_INT_ST, RO ; CPU4 interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 3, 1, WAKEUP_CPU3_INT_ST, RO ; CPU3 interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 2, 1, WAKEUP_CPU2_INT_ST, RO ; CPU2 interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 1, 1, WAKEUP_CPU1_INT_ST, RO ; CPU1 interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

> 0, 1, WAKEUP_CPU0_INT_ST, RO ; CPU0 interrupt as wake up source status.
= 0, INACTIVE
= 1, ACTIVE

PMU_DDR_CH0_PWR_CON = 0x4020 ; DDR channel 0 hardware power control register
> 10, 1, DDRPHY_AUTO_GATING_ENA ; Enable DDRPHY auto clock gating. DDRPHY's clock can be gated when in sleep mode.
= 0, DISABLE
= 1, ENABLE

> 9, 1, DDRCTL_C_AUTO_GATING_ENA ; Enable DDRCTRL's core-clock auto clock gating. Core-clock can be gated when in self-refresh mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, DDRCTL_A_AUTO_GATING_ENA ; Enable DDRCTRL's AXI-clock auto clock gating. AXI-clock can be gated when in self-refresh mode.
= 0, DISABLE
= 1, ENABLE

> 7, 1, DDRIO_RSTIOV_EXIT_ENA ; Enable DDR exits retention mode through RST_IOV by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, DDRIO_RSTIOV_ENTER_ENA ; Enable DDR enters retention mode through RST_IOV by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, DDRIO_RETON_EXIT_ENA ; Enable DDR exits retention mode through RETON/RETOFF by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, DDRIO_RETON_ENTER_ENA ; Enable DDR enters retention mode through RETON/RETOFF by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, DDR_SREF_A_ENA ; Enable DDR self-refresh mode for AXI-clock domain by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, DDR_SREF_C_ENA ; Enable DDR self-refresh mode for core-clock domain by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_DDR_CH1_PWR_CON = 0x4024 ; DDR channel 1 hardware power control register
> 10, 1, DDRPHY_AUTO_GATING_ENA ; Enable DDRPHY auto clock gating. DDRPHY's clock can be gated when in sleep mode.
= 0, DISABLE
= 1, ENABLE

> 9, 1, DDRCTL_C_AUTO_GATING_ENA ; Enable DDRCTRL's core-clock auto clock gating. Core-clock can be gated when in self-refresh mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, DDRCTL_A_AUTO_GATING_ENA ; Enable DDRCTRL's AXI-clock auto clock gating. AXI-clock can be gated when in self-refresh mode.
= 0, DISABLE
= 1, ENABLE

> 7, 1, DDRIO_RSTIOV_EXIT_ENA ; Enable DDR exits retention mode through RST_IOV by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, DDRIO_RSTIOV_ENTER_ENA ; Enable DDR enters retention mode through RST_IOV by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, DDRIO_RETON_EXIT_ENA ; Enable DDR exits retention mode through RETON/RETOFF by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, DDRIO_RETON_ENTER_ENA ; Enable DDR enters retention mode through RETON/RETOFF by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, DDR_SREF_A_ENA ; Enable DDR self-refresh mode for AXI-clock domain by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, DDR_SREF_C_ENA ; Enable DDR self-refresh mode for core-clock domain by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_DDR_CH2_PWR_CON = 0x4028 ; DDR channel 2 hardware power control register
> 10, 1, DDRPHY_AUTO_GATING_ENA ; Enable DDRPHY auto clock gating. DDRPHY's clock can be gated when in sleep mode.
= 0, DISABLE
= 1, ENABLE

> 9, 1, DDRCTL_C_AUTO_GATING_ENA ; Enable DDRCTRL's core-clock auto clock gating. Core-clock can be gated when in self-refresh mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, DDRCTL_A_AUTO_GATING_ENA ; Enable DDRCTRL's AXI-clock auto clock gating. AXI-clock can be gated when in self-refresh mode.
= 0, DISABLE
= 1, ENABLE

> 7, 1, DDRIO_RSTIOV_EXIT_ENA ; Enable DDR exits retention mode through RST_IOV by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, DDRIO_RSTIOV_ENTER_ENA ; Enable DDR enters retention mode through RST_IOV by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, DDRIO_RETON_EXIT_ENA ; Enable DDR exits retention mode through RETON/RETOFF by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, DDRIO_RETON_ENTER_ENA ; Enable DDR enters retention mode through RETON/RETOFF by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, DDR_SREF_A_ENA ; Enable DDR self-refresh mode for AXI-clock domain by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, DDR_SREF_C_ENA ; Enable DDR self-refresh mode for core-clock domain by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_DDR_CH3_PWR_CON = 0x402C ; DDR channel 3 hardware power control register
> 10, 1, DDRPHY_AUTO_GATING_ENA ; Enable DDRPHY auto clock gating. DDRPHY's clock can be gated when in sleep mode.
= 0, DISABLE
= 1, ENABLE

> 9, 1, DDRCTL_C_AUTO_GATING_ENA ; Enable DDRCTRL's core-clock auto clock gating. Core-clock can be gated when in self-refresh mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, DDRCTL_A_AUTO_GATING_ENA ; Enable DDRCTRL's AXI-clock auto clock gating. AXI-clock can be gated when in self-refresh mode.
= 0, DISABLE
= 1, ENABLE

> 7, 1, DDRIO_RSTIOV_EXIT_ENA ; Enable DDR exits retention mode through RST_IOV by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, DDRIO_RSTIOV_ENTER_ENA ; Enable DDR enters retention mode through RST_IOV by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, DDRIO_RETON_EXIT_ENA ; Enable DDR exits retention mode through RETON/RETOFF by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, DDRIO_RETON_ENTER_ENA ; Enable DDR enters retention mode through RETON/RETOFF by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, DDR_SREF_A_ENA ; Enable DDR self-refresh mode for AXI-clock domain by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, DDR_SREF_C_ENA ; Enable DDR self-refresh mode for core-clock domain by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_DDR_CH0_PWR_SFTCON = 0x4030 ; DDR channel 0 software power control register
> 11, 1, DDRCTL_C_ACTIVE_WAIT_ENTER ;
= 0, NOT_NEED ; Not need to wait for ddrctl_c_active low before FSM enter self-refresh state
= 1, NEED ; Need to wait for ddrctl_c_active low before FSM enter self- refresh state

> 10, 1, DDRCTL_A_ACTIVE_WAIT_EXIT ;
= 0, NOT_NEED ; Not need to wait for ddrctl_a_active high before FSM exit self-refresh state
= 1, NEED ; Need to wait for ddrctl_a_active high before FSM exit self- refresh state

> 9, 1, DDRCTL_C_ACTIVE_WAIT_EXIT ;
= 0, NOT_NEED ; Not need to wait for ddrctl_c_active high before FSM exit self-refresh state
= 1, NEED ; Need to wait for ddrctl_c_active high before FSM exit self- refresh state

> 8, 1, DDRCTL_A_ACTIVE_WAIT_ENTER ;
= 0, NOT_NEED ; Not need to wait for ddrctl_a_active low before FSM enter self-refresh state
= 1, NEED ; Need to wait for ddrctl_a_active low before FSM enter self- refresh state

> 7, 1, DDRIO_RSTIOV_EXIT_SFTENA ; Enable DDR exits retention mode through RST_IOV by software. It is auto cleared after DDR exits retention mode.
= 0, DISABLE
= 1, ENABLE

> 6, 1, DDRIO_RSTIOV_ENTER_SFTENA ; Enable DDR enters retention mode through RST_IOV by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, DDRIO_RETON_EXIT_SFTENA ; Enable DDR exits retention mode through RETON/RETOFF by software. It is auto cleared after DDR exits retention mode.
= 0, DISABLE
= 1, ENABLE

> 2, 1, DDRIO_RETON_ENTER_SFTENA ; Enable DDR enters retention mode through RETON/RETOFF by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, DDR_SREF_A_SFTENA ; Enable DDR self-refresh mode for AXI-clock domain by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, DDR_SREF_C_SFTENA ; Enable DDR self-refresh mode for core-clock domain by software.
= 0, DISABLE
= 1, ENABLE

PMU_DDR_CH1_PWR_SFTCON = 0x4034 ; DDR channel 1 software power control register
> 11, 1, DDRCTL_C_ACTIVE_WAIT_ENTER ;
= 0, NOT_NEED ; Not need to wait for ddrctl_c_active low before FSM enter self-refresh state
= 1, NEED ; Need to wait for ddrctl_c_active low before FSM enter self- refresh state

> 10, 1, DDRCTL_A_ACTIVE_WAIT_EXIT ;
= 0, NOT_NEED ; Not need to wait for ddrctl_a_active high before FSM exit self-refresh state
= 1, NEED ; Need to wait for ddrctl_a_active high before FSM exit self- refresh state

> 9, 1, DDRCTL_C_ACTIVE_WAIT_EXIT ;
= 0, NOT_NEED ; Not need to wait for ddrctl_c_active high before FSM exit self-refresh state
= 1, NEED ; Need to wait for ddrctl_c_active high before FSM exit self- refresh state

> 8, 1, DDRCTL_A_ACTIVE_WAIT_ENTER ;
= 0, NOT_NEED ; Not need to wait for ddrctl_a_active low before FSM enter self-refresh state
= 1, NEED ; Need to wait for ddrctl_a_active low before FSM enter self- refresh state

> 7, 1, DDRIO_RSTIOV_EXIT_SFTENA ; Enable DDR exits retention mode through RST_IOV by software. It is auto cleared after DDR exits retention mode.
= 0, DISABLE
= 1, ENABLE

> 6, 1, DDRIO_RSTIOV_ENTER_SFTENA ; Enable DDR enters retention mode through RST_IOV by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, DDRIO_RETON_EXIT_SFTENA ; Enable DDR exits retention mode through RETON/RETOFF by software. It is auto cleared after DDR exits retention mode.
= 0, DISABLE
= 1, ENABLE

> 2, 1, DDRIO_RETON_ENTER_SFTENA ; Enable DDR enters retention mode through RETON/RETOFF by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, DDR_SREF_A_SFTENA ; Enable DDR self-refresh mode for AXI-clock domain by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, DDR_SREF_C_SFTENA ; Enable DDR self-refresh mode for core-clock domain by software.
= 0, DISABLE
= 1, ENABLE

PMU_DDR_CH2_PWR_SFTCON = 0x4038 ; DDR channel 2 software power control register
> 11, 1, DDRCTL_C_ACTIVE_WAIT_ENTER ;
= 0, NOT_NEED ; Not need to wait for ddrctl_c_active low before FSM enter self-refresh state
= 1, NEED ; Need to wait for ddrctl_c_active low before FSM enter self- refresh state

> 10, 1, DDRCTL_A_ACTIVE_WAIT_EXIT ;
= 0, NOT_NEED ; Not need to wait for ddrctl_a_active high before FSM exit self-refresh state
= 1, NEED ; Need to wait for ddrctl_a_active high before FSM exit self- refresh state

> 9, 1, DDRCTL_C_ACTIVE_WAIT_EXIT ;
= 0, NOT_NEED ; Not need to wait for ddrctl_c_active high before FSM exit self-refresh state
= 1, NEED ; Need to wait for ddrctl_c_active high before FSM exit self- refresh state

> 8, 1, DDRCTL_A_ACTIVE_WAIT_ENTER ;
= 0, NOT_NEED ; Not need to wait for ddrctl_a_active low before FSM enter self-refresh state
= 1, NEED ; Need to wait for ddrctl_a_active low before FSM enter self- refresh state

> 7, 1, DDRIO_RSTIOV_EXIT_SFTENA ; Enable DDR exits retention mode through RST_IOV by software. It is auto cleared after DDR exits retention mode.
= 0, DISABLE
= 1, ENABLE

> 6, 1, DDRIO_RSTIOV_ENTER_SFTENA ; Enable DDR enters retention mode through RST_IOV by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, DDRIO_RETON_EXIT_SFTENA ; Enable DDR exits retention mode through RETON/RETOFF by software. It is auto cleared after DDR exits retention mode.
= 0, DISABLE
= 1, ENABLE

> 2, 1, DDRIO_RETON_ENTER_SFTENA ; Enable DDR enters retention mode through RETON/RETOFF by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, DDR_SREF_A_SFTENA ; Enable DDR self-refresh mode for AXI-clock domain by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, DDR_SREF_C_SFTENA ; Enable DDR self-refresh mode for core-clock domain by software.
= 0, DISABLE
= 1, ENABLE

PMU_DDR_CH3_PWR_SFTCON = 0x403C ; DDR channel 3 software power control register
> 11, 1, DDRCTL_C_ACTIVE_WAIT_ENTER ;
= 0, NOT_NEED ; Not need to wait for ddrctl_c_active low before FSM enter self-refresh state
= 1, NEED ; Need to wait for ddrctl_c_active low before FSM enter self- refresh state

> 10, 1, DDRCTL_A_ACTIVE_WAIT_EXIT ;
= 0, NOT_NEED ; Not need to wait for ddrctl_a_active high before FSM exit self-refresh state
= 1, NEED ; Need to wait for ddrctl_a_active high before FSM exit self- refresh state

> 9, 1, DDRCTL_C_ACTIVE_WAIT_EXIT ;
= 0, NOT_NEED ; Not need to wait for ddrctl_c_active high before FSM exit self-refresh state
= 1, NEED ; Need to wait for ddrctl_c_active high before FSM exit self- refresh state

> 8, 1, DDRCTL_A_ACTIVE_WAIT_ENTER ;
= 0, NOT_NEED ; Not need to wait for ddrctl_a_active low before FSM enter self-refresh state
= 1, NEED ; Need to wait for ddrctl_a_active low before FSM enter self- refresh state

> 7, 1, DDRIO_RSTIOV_EXIT_SFTENA ; Enable DDR exits retention mode through RST_IOV by software. It is auto cleared after DDR exits retention mode.
= 0, DISABLE
= 1, ENABLE

> 6, 1, DDRIO_RSTIOV_ENTER_SFTENA ; Enable DDR enters retention mode through RST_IOV by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, DDRIO_RETON_EXIT_SFTENA ; Enable DDR exits retention mode through RETON/RETOFF by software. It is auto cleared after DDR exits retention mode.
= 0, DISABLE
= 1, ENABLE

> 2, 1, DDRIO_RETON_ENTER_SFTENA ; Enable DDR enters retention mode through RETON/RETOFF by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, DDR_SREF_A_SFTENA ; Enable DDR self-refresh mode for AXI-clock domain by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, DDR_SREF_C_SFTENA ; Enable DDR self-refresh mode for core-clock domain by software.
= 0, DISABLE
= 1, ENABLE

PMU_DDR_POWER_STS = 0x4040 ; DDR power state register
> 0, 4, DDR_POWER_STATE, RO ; DDR power state.
= 0, _ ; Normal state
= 1, _ ; Enter self-refresh mode for AXI-clock state
= 2, _ ; Enter self-refresh mode core-clock state
= 3, _ ; Enter retention mode through RETON/RETOFF state
= 4, _ ; Enter retention mode through RST_IOV state
= 5, _ ; Sleep state
= 6, _ ; Exit retention mode through RST_IOV state
= 7, _ ; Exit retention mode through RETON/RETOFF state
= 8, _ ; Exit self-refresh mode for core-clock state
= 9, _ ; Exit self-refresh mode for AXI-clock state

PMU_DDR_STS = 0x4044 ; DDR state register
> 29, 1, DDR_CH3_IO_RSTIOV, RO ; DDR RST_IOV state for channel 3.
= 0, INACTIVE
= 1, ACTIVE

> 28, 1, DDRCTRL_CH3_A_SYSACTIVE, RO ; DDRC AXI clock active for channel 3.
= 0, INACTIVE
= 1, ACTIVE

> 27, 1, DDRCTRL_CH3_A_SYSACK, RO ; DDRC AXI hardware low-power request acknowledge for channel 3.
= 0, INACTIVE
= 1, ACTIVE

> 26, 1, DDR_CH3_IO_RETON, RO ; DDR RETON/RETOFF state for channel 3.
= 0, INACTIVE
= 1, ACTIVE

> 25, 1, DDRCTRL_CH3_C_SYSACTIVE, RO ; DDRC hardware low-power clock active for channel 3.
= 0, INACTIVE
= 1, ACTIVE

> 24, 1, DDRCTRL_CH3_C_SYSACK, RO ; DDRC hardware low-power request acknowledge for channel 3.
= 0, INACTIVE
= 1, ACTIVE

> 21, 1, DDR_CH2_IO_RSTIOV, RO ; DDR RST_IOV state for channel 2.
= 0, INACTIVE
= 1, ACTIVE

> 20, 1, DDRCTRL_CH2_A_SYSACTIVE, RO ; DDRC AXI clock active for channel 2.
= 0, INACTIVE
= 1, ACTIVE

> 19, 1, DDRCTRL_CH2_A_SYSACK, RO ; DDRC AXI hardware low-power request acknowledge for channel 2.
= 0, INACTIVE
= 1, ACTIVE

> 18, 1, DDR_CH2_IO_RETON, RO ; DDR RETON/RETOFF state for channel 2.
= 0, INACTIVE
= 1, ACTIVE

> 17, 1, DDRCTRL_CH2_C_SYSACTIVE, RO ; DDRC hardware low-power clock active for channel 2.
= 0, INACTIVE
= 1, ACTIVE

> 16, 1, DDRCTRL_CH2_C_SYSACK, RO ; DDRC hardware low-power request acknowledge for channel 2.
= 0, INACTIVE
= 1, ACTIVE

> 13, 1, DDR_CH1_IO_RSTIOV, RO ; DDR RST_IOV state for channel 1.
= 0, INACTIVE
= 1, ACTIVE

> 12, 1, DDRCTRL_CH1_A_SYSACTIVE, RO ; DDRC AXI clock active for channel 1.
= 0, INACTIVE
= 1, ACTIVE

> 11, 1, DDRCTRL_CH1_A_SYSACK, RO ; DDRC AXI hardware low-power request acknowledge for channel 1.
= 0, INACTIVE
= 1, ACTIVE

> 10, 1, DDR_CH1_IO_RETON, RO ; DDR RETON/RETOFF state for channel 1.
= 0, INACTIVE
= 1, ACTIVE

> 9, 1, DDRCTRL_CH1_C_SYSACTIVE, RO ; DDRC hardware low-power clock active for channel 1.
= 0, INACTIVE
= 1, ACTIVE

> 8, 1, DDRCTRL_CH1_C_SYSACK, RO ; DDRC hardware low-power request acknowledge for channel 1.
= 0, INACTIVE
= 1, ACTIVE

> 5, 1, DDR_CH0_IO_RSTIOV, RO ; DDR RST_IOV state for channel 0.
= 0, INACTIVE
= 1, ACTIVE

> 4, 1, DDRCTRL_CH0_A_SYSACTIVE, RO ; DDRC AXI clock active for channel 0.
= 0, INACTIVE
= 1, ACTIVE

> 3, 1, DDRCTRL_CH0_A_SYSACK, RO ; DDRC AXI hardware low-power request acknowledge for channel 0.
= 0, INACTIVE
= 1, ACTIVE

> 2, 1, DDR_CH0_IO_RETON, RO ; DDR RETON/RETOFF state for channel 0.
= 0, INACTIVE
= 1, ACTIVE

> 1, 1, DDRCTRL_CH0_C_SYSACTIVE, RO ; DDRC hardware low-power clock active for channel 0.
= 0, INACTIVE
= 1, ACTIVE

> 0, 1, DDRCTRL_CH0_C_SYSACK, RO ; DDRC hardware low-power request acknowledge for channel 0.
= 0, INACTIVE
= 1, ACTIVE

PMU_CRU_PWR_CON = 0x4050 ; Clock and reset hardware power control register
> 10, 1, POWER_OFF_IO_ENA ; Enable VCCIO enter low power mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_BUS_CLK_SRC_GATE_ENA ; Gating BIU_BUS's clock source during clock low power mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PWM_SWITCH_IOUT ; PWM output.
= 0, DISABLE
= 1, ENABLE ; It is set 0 for RK3588.

> 7, 1, PWM_GPIO_IOE_ENA ; PWM output enable.
= 0, DISABLE
= 1, ENABLE ;` It is set 0 for RK3588.

> 6, 1, PWM_SWITCH_ENA ; PWM switch enable.
= 0, DISABLE
= 1, ENABLE ;` It is set 0 for RK3588.

> 5, 1, POWER_OFF_ENA ; Enable chip power off by hardware.
= 0, DISABLE
= 1, ENABLE

> 4, 1, ALIVE_OSC_ENA ; Enable clk_pmu/hclk_pmu/pclk_pmu switch to oscillator by hardware. When alive_32k_ena is asserted, this bit is ignored.
= 0, DISABLE
= 1, ENABLE

> 3, 1, INPUT_CLAMP_ENA ; Enable VD_PMU input clamped by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, WAKEUP_RST_ENA ; Enable wake up reset by hardware. If asserted, all registers without reset hold will be reset after chip wake up.
= 0, DISABLE
= 1, ENABLE

> 1, 1, OSC_DIS_ENA ; Disable oscillator by hardware.
= 0, ENABLE
= 1, DISABLE

> 0, 1, ALIVE_32K_ENA ; Enable pclk_pmu and clk_pmu switch to 32KHz clock by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_CRU_PWR_SFTCON = 0x4054 ; Clock and reset software power control register
> 6, 1, POWER_OFF_IO_SFTENA ; Enable VCCIO enter low power mode by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, POWER_OFF_SFTENA ; Enable chip power off by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, ALIVE_OSC_SFTENA ; Enable clk_pmu/hclk_pmu/pclk_pmu switch to oscillator by software. When alive_32k_ena is asserted, this bit is ignored.
= 0, DISABLE
= 1, ENABLE

> 3, 1, INPUT_CLAMP_SFTENA ; Enable VD_PMU input clamp by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, WAKEUP_RST_SFTENA ; Enable wake up reset by software. If asserted, all digital except IP with reset hold will be reset.
= 0, DISABLE
= 1, ENABLE

> 1, 1, OSC_DIS_SFTENA ; Disable oscillator by software.
= 0, ENABLE
= 1, DISABLE

> 0, 1, ALIVE_32K_SFTENA ; Enable pclk_pmu and clk_pmu switch to 32KHz clock by software.
= 0, DISABLE
= 1, ENABLE

PMU_CRU_POWER_STS = 0x4058 ; Clock and reset power state register
> 0, 4, CRU_POWER_STATE, RO ; Clock and reset power state.
= 0, _ ; Normal state
= 1, _ ; Clock low frequency state
= 2, _ ; PLL power down state
= 3, _ ; Input clamp state
= 4, _ ; Oscillator disable state
= 5, _ ; Sleep state
= 6, _ ; Wake up state
= 7, _ ; Input clamp release state
= 8, _ ; Oscillator enable state
= 9, _ ; Clock high frequency state
= 10, _ ; Wake up reset clear state
= 12, _ ; PLL power up state

PMU_PLLPD_CON0 = 0x4060 ; PLL hardware power control register 0
> 15, 1, NPLL_PD_ENA ; Enable power down NPLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 14, 1, CPLL_PD_ENA ; Enable power down CPLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 13, 1, GPLL_PD_ENA ; Enable power down GPLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 12, 1, AUPLL_PD_ENA ; Enable power down AUPLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 11, 1, V0PLL_PD_ENA ; Enable power down V0PLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, D3BPLL_PD_ENA ; Enable power down D3BPLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, D3APLL_PD_ENA ; Enable power down D3APLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 8, 1, D2BPLL_PD_ENA ; Enable power down D2BPLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, D2APLL_PD_ENA ; Enable power down D2APLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, D1BPLL_PD_ENA ; Enable power down D1BPLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, D1APLL_PD_ENA ; Enable power down D1APLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 4, 1, D0BPLL_PD_ENA ; Enable power down D0BPLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, D0APLL_PD_ENA ; Enable power down D0APLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, LPLL_PD_ENA ; Enable power down LPLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, B1PLL_PD_ENA ; Enable power down B1PLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, B0PLL_PD_ENA ; Enable power down B0PLL by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_PLLPD_CON1 = 0x4064 ; PLL hardware power control register 1
> 1, 1, SPLL_PD_ENA ; Enable power down SPLL by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PPLL_PD_ENA ; Enable power down PPLL by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_PLLPD_SFTCON0 = 0x4068 ; PLL software power control register 0
> 15, 1, NPLL_PD_SFTENA ; Enable power down NPLL by software.
= 0, DISABLE
= 1, ENABLE

> 14, 1, CPLL_PD_SFTENA ; Enable power down CPLL by software.
= 0, DISABLE
= 1, ENABLE

> 13, 1, GPLL_PD_SFTENA ; Enable power down GPLL by software.
= 0, DISABLE
= 1, ENABLE

> 12, 1, AUPLL_PD_SFTENA ; Enable power down AUPLL by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, V0PLL_PD_SFTENA ; Enable power down V0PLL by software.
= 0, DISABLE
= 1, ENABLE

> 10, 1, D3BPLL_PD_SFTENA ; Enable power down D3BPLL by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, D3APLL_PD_SFTENA ; Enable power down D3APLL by software.
= 0, DISABLE
= 1, ENABLE

> 8, 1, D2BPLL_PD_SFTENA ; Enable power down D2BPLL by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, D2APLL_PD_SFTENA ; Enable power down D2APLL by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, D1BPLL_PD_SFTENA ; Enable power down D1BPLL by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, D1APLL_PD_SFTENA ; Enable power down D1APLL by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, D0BPLL_PD_SFTENA ; Enable power down D0BPLL by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, D0APLL_PD_SFTENA ; Enable power down D0APLL by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, LPLL_PD_SFTENA ; Enable power down LPLL by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, B1PLL_PD_SFTENA ; Enable power down B1PLL by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, B0PLL_PD_SFTENA ; Enable power down B0PLL by software.
= 0, DISABLE
= 1, ENABLE

PMU_PLLPD_SFTCON1 = 0x406C ; PLL software power control register 1
> 1, 1, SPLL_PD_SFTENA ; Enable power down SPLL by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PPLL_PD_SFTENA ; Enable power down PPLL by software.
= 0, DISABLE
= 1, ENABLE

PMU_PMIC_STABLE_CNT = 0x4080 ; PMIC stable count register
> 0, 20, PMIC_STABLE_CNT ; PMIC stable count for mode 1 procedure. Number of clk_pmu used by counter logic.

PMU_OSC_STABLE_CNT = 0x4084 ; Oscillator stable count register
> 0, 20, OSC_STABLE_CNT ; Oscillator stable count for mode 1 procedure. Number of clk_pmu used by counter logic.

PMU_WAKEUP_RST_CLR_CNT = 0x4088 ; Wake up reset clear count register
> 0, 20, WAKEUP_RST_CLR_CNT ; Wake up reset clear count for mode 1 procedure. Number of clk_pmu used by counter logic.

PMU_PLL_LOCK_CNT = 0x408C ; PLL lock count register
> 0, 20, PLL_LOCK_CNT ; Count for PLL from power up to lock. Number of clk_pmu used by counter logic.

PMU_WAKEUP_TIMEOUT_CNT = 0x4094 ; PMU wake up timeout count register
> 0, 20, WAKEUP_TIMEOUT_CNT ; Wake up timeout count. Number of clk_pmu used by counter logic.

PMU_PWM_SWITCH_CNT = 0x4098 ; PWM switch stable count register
> 0, 20, PWM_SWITCH_CNT ; PWM switch count. Number of clk_pmu used by counter logic.

PMU_SYS_REG0 = 0x4100 ; PMU system register 0. It cannot be reset by software.
PMU_SYS_REG1 = 0x4104 ; PMU system register 1. It cannot be reset by software.
PMU_SYS_REG2 = 0x4108 ; PMU system register 2. It cannot be reset by software.
PMU_SYS_REG3 = 0x410C ; PMU system register 3. It cannot be reset by software.
PMU_SYS_REG4 = 0x4110 ; PMU system register 4. It cannot be reset by software.
PMU_SYS_REG5 = 0x4114 ; PMU system register 5. It cannot be reset by software.
PMU_SYS_REG6 = 0x4118 ; PMU system register 6. It cannot be reset by software.
PMU_SYS_REG7 = 0x411C ; PMU system register 7. It cannot be reset by software.

PMU_PWR_CON2 = 0x8000 ; PMU hardware power control 2 register
> 7, 1, CPU7_LP_BYPASS ; Bypass CPU7 low power flow.
= 0, DISABLE
= 1, ENABLE

> 6, 1, CPU6_LP_BYPASS ; Bypass CPU6 low power flow.
= 0, DISABLE
= 1, ENABLE

> 5, 1, CPU5_LP_BYPASS ; Bypass CPU5 low power flow.
= 0, DISABLE
= 1, ENABLE

> 4, 1, CPU4_LP_BYPASS ; Bypass CPU4 low power flow.
= 0, DISABLE
= 1, ENABLE

> 3, 1, CPU3_LP_BYPASS ; Bypass CPU3 low power flow.
= 0, DISABLE
= 1, ENABLE

> 2, 1, CPU2_LP_BYPASS ; Bypass CPU2 low power flow.
= 0, DISABLE
= 1, ENABLE

> 1, 1, CPU1_LP_BYPASS ; Bypass CPU1 low power flow.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CPU0_LP_BYPASS ; Bypass CPU0 low power flow.
= 0, DISABLE
= 1, ENABLE

PMU_DSU_PWR_CON = 0x8004 ; DSU hardware power control register
> 10, 1, DSU_MEM_DWN_ACK_CLAMP_ENA ; Enable clamp for VD_DSU memory power down acknowledge. This bit should be set to 1 if dsu_pwroff_ena=1 and VD_DSU will be power off.
= 0, DISABLE
= 1, ENABLE

# Following 5 bits were in a single field: Bypass VD_DSU memory power down acknowledge.
> 9, 1, DSU_MEM_DWN_ACK_BYPASS9; used to bypass other memory power down acknowledge. If memory is power down before DSU enter power down mode, you should set relative bypass bit high.
= 0, DISABLE
= 1, ENABLE

> 8, 1, DSU_MEM_DWN_ACK_BYPASS8; used to bypass "L3 Tag ways 8~11, L3 Data portion 1 RAMs" memory power down acknowledge.
= 0, DISABLE
= 1, ENABLE

> 7, 1, DSU_MEM_DWN_ACK_BYPASS7; used to bypass "L3 Tag ways 4~7" memory power down acknowledge.
= 0, DISABLE
= 1, ENABLE

> 6, 1, DSU_MEM_DWN_ACK_BYPASS6; used to bypass "L3 Tag ways 0~3, L3 Data portion 0, and L3 Victim RAMs" memory power down acknowledge.
= 0, DISABLE
= 1, ENABLE

> 5, 1, DSU_MEM_DWN_ACK_BYPASS5; used to bypass "Snoop filter and LTDB RAMs" memory power down acknowledge.
= 0, DISABLE
= 1, ENABLE

> 3, 1, DSU_FUNCRET_ENA ; Enable DSU FUNC_RET mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, DSU_CLUSTERPACTIVE_BIT_FULL_FLAG ; CLUSTERPACTIVE bit full flag. If DSU power mode wants to transfer from any mode to FULL ON or FULL FUNC_RET, this bit should be set to 1. Otherwise, this bit should be set to 0.

> 1, 1, DSU_PWROFF_ENA ; Enable VD_LITDSU power off by hardware. If you just power down VD_LITDSU memory but not power off VD_LITDSU, this bit should be set to 0. If you want to power off VD_LITDSU by hardware, this bit should be set to 1.
= 0, DISABLE
= 1, ENABLE

> 0, 1, DSU_PWRDN_ENA ; Enable VD_LITDSU power down by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_DSU_PWR_SFTCON = 0x8008 ; DSU software power control register
> 12, 1, DSU_SFT_CLUSTERPACTIVE_RETSF ; CLUSTERPACTIVE bit generated by software when requested mode is SFONLY FUNC_RET mode. High active. It is auto cleared when CLUSTERPREQ is active. It is used when DSU power mode transition is controlled by software.
= 1, ACTIVE

> 11, 1, DSU_SFT_CLUSTERPACTIVE_RET1P4 ; CLUSTERPACTIVE bit generated by software when requested mode is 1/4 FUNC_RET mode. High active. It is auto cleared when CLUSTERPREQ is active. It is used when DSU power mode transition is controlled by software.
= 1, ACTIVE

> 10, 1, DSU_SFT_CLUSTERPACTIVE_RET1P2 ; CLUSTERPACTIVE bit generated by software when requested mode is 1/2 FUNC_RET mode. High active. It is auto cleared when CLUSTERPREQ is active. It is used when DSU power mode transition is controlled by software.
= 1, ACTIVE

> 9, 1, DSU_SFT_CLUSTERPACTIVE_RET3P4 ; CLUSTERPACTIVE bit generated by software when requested mode is 3/4 FUNC_RET mode. High active. It is auto cleared when CLUSTERPREQ is active. It is used when DSU power mode transition is controlled by software.
= 1, ACTIVE

> 8, 1, DSU_SFT_CLUSTERPACTIVE_ONSF ; CLUSTERPACTIVE bit generated by software when requested mode is SFONLY ON mode. High active. It is auto cleared when CLUSTERPREQ is active. It is used when DSU power mode transition is controlled by software.
= 1, ACTIVE

> 7, 1, DSU_SFT_CLUSTERPACTIVE_ON1P4 ; CLUSTERPACTIVE bit generated by software when requested mode is 1/4 ON mode. High active. It is auto cleared when CLUSTERPREQ is active. It is used when DSU power mode transition is controlled by software.
= 1, ACTIVE

> 6, 1, DSU_SFT_CLUSTERPACTIVE_ON1P2 ; CLUSTERPACTIVE bit generated by software when requested mode is 1/2 ON mode. High active. It is auto cleared when CLUSTERPREQ is active. It is used when DSU power mode transition is controlled by software.
= 1, ACTIVE

> 5, 1, DSU_SFT_CLUSTERPACTIVE_ON3P4 ; CLUSTERPACTIVE bit generated by software when requested mode is 3/4 ON mode. High active. It is auto cleared when CLUSTERPREQ is active. It is used when DSU power mode transition is controlled by software.
= 1, ACTIVE

> 4, 1, DSU_SFT_CLUSTERPACTIVE_FUNCRET ; CLUSTERPACTIVE bit generated by software when requested mode is FUNC_RET mode. High active. It is auto cleared when CLUSTERPREQ is active. It is used when DSU power mode transition is controlled by software.
= 1, ACTIVE

> 3, 1, DSU_SFT_CLUSTERPACTIVE_FULLON ; CLUSTERPACTIVE bit generated by software when requested mode is FULL ON mode. High active. It is auto cleared when CLUSTERPREQ is active. It is used when DSU power mode transition is controlled by software.
= 1, ACTIVE

> 2, 1, DSU_SFT_CLUSTERPACTIVE_OFF ; CLUSTERPACTIVE bit generated by software when requested mode is OFF mode. High active. It is auto cleared when CLUSTERPREQ is active. It is used when DSU power mode transition is controlled by software.
= 1, ACTIVE

> 1, 1, DSU_PWROFF_SFTENA ; Enable VD_LITDSU power off by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, DSU_PWRDN_SFTENA ; Enable VD_LITDSU power down by software.
= 0, DISABLE
= 1, ENABLE

PMU_DSU_AUTO_PWR_CON = 0x800C ; DSU automatic power control register
> 13, 1, DSU_AUTO_RETSF_ENA ; Enable DSU enters SFONLY FUNC_RET mode automatically.
= 0, DISABLE
= 1, ENABLE

> 12, 1, DSU_AUTO_RET1P4_ENA ; Enable DSU enters 1/4 FUNC_RET mode automatically.
= 0, DISABLE
= 1, ENABLE

> 11, 1, DSU_AUTO_RET1P2_ENA ; Enable DSU enters 1/2 FUNC_RET mode automatically.
= 0, DISABLE
= 1, ENABLE

> 10, 1, DSU_AUTO_RET3P4_ENA ; Enable DSU enters 3/4 FUNC_RET mode automatically.
= 0, DISABLE
= 1, ENABLE

> 9, 1, DSU_AUTO_ONSF_ENA ; Enable DSU enters SFONLY ON mode automatically.
= 0, DISABLE
= 1, ENABLE

> 8, 1, DSU_AUTO_ON1P4_ENA ; Enable DSU enters 1/4 ON mode automatically.
= 0, DISABLE
= 1, ENABLE

> 7, 1, DSU_AUTO_ON1P2_ENA ; Enable DSU enters 1/2 ON mode automatically.
= 0, DISABLE
= 1, ENABLE

> 6, 1, DSU_AUTO_ON3P4_ENA ; Enable DSU enters 3/4 ON mode automatically.
= 0, DISABLE
= 1, ENABLE

> 5, 1, DSU_AUTO_FULLON_ENA ; Enable DSU enters FULL ON mode automatically.
= 0, DISABLE
= 1, ENABLE

> 4, 1, DSU_AUTO_FUNCRET_ENA ; Enable DSU enters FUNC_RET mode automatically.
= 0, DISABLE
= 1, ENABLE

> 3, 1, DSU_SFT_WAKEUP_ENA ; Enable VD_LITDSU wake up by software.
= 0, INACTIVE ; Wake up source inactive
= 1, ACTIVE ; Wake up source active

> 1, 1, DSU_INT_WAKEUP_ENA ; Enable interrupt as VD_LITDSU wake up source.
= 0, DISABLE
= 1, ENABLE

> 0, 1, DSU_LP_EN ; Enable VD_LITDSU low power mode.
= 0, DISABLE
= 1, ENABLE

PMU_CPU0_AUTO_PWR_CON = 0x8010 ; CPU0 automatic power control register
> 11, 1, CPU_DBGRCV_NCPUPORESET_ENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, CPU_DBGRCV_NCORERESET_ENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, CPU_ONLY_MEMOFF_ENA ; Enable only power down CPU memory. i.e., just power down memory, but not other digital logic when CPU in OFF mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, CPU_AUTO_EMUOFF_ENA ; Enable CPU emulated off mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_MEM_LS_ENA ; Enable CPU memory light sleep mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, CPU_DBGRCV_ENA ; Enable CPU debug recovery mode by hardware. It is auto cleared when FSM enters debug recovery state.
= 0, DISABLE
= 1, ENABLE

> 4, 1, CPU_AUTO_RET_ENA ; Enable CPU retention mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, CPU_SFT_WAKEUP_ENA ; Enable CPU wake up by software.
= 0, INACTIVE ; Wake up source inactive
= 1, ACTIVE ; Wake up source active

> 1, 1, CPU_INT_WAKEUP_ENA ; Enable interrupt as CPU wake up source.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CPU_AUTO_PWRDN_ENA ; Enable CPU power down automatically.
= 0, DISABLE
= 1, ENABLE

PMU_CPU1_AUTO_PWR_CON = 0x8014 ; CPU1 automatic power control register
> 11, 1, CPU_DBGRCV_NCPUPORESET_ENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, CPU_DBGRCV_NCORERESET_ENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, CPU_ONLY_MEMOFF_ENA ; Enable only power down CPU memory. i.e., just power down memory, but not other digital logic when CPU in OFF mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, CPU_AUTO_EMU_ENA ; Enable CPU emulated off mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_MEM_LS_ENA ; Enable CPU memory light sleep mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, CPU_DBGRCV_ENA ; Enable CPU debug recovery mode by hardware. It is auto cleared when FSM enters debug recovery state.
= 0, DISABLE
= 1, ENABLE

> 4, 1, CPU_AUTO_RET_ENA ; Enable CPU retention mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, CPU_SFT_WAKEUP_ENA ; Enable CPU wake up by software.
= 0, INACTIVE ; Wake up source inactive
= 1, ACTIVE ; Wake up source active

> 1, 1, CPU_INT_WAKEUP_ENA ; Enable interrupt as CPU wake up source.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CPU_AUTO_PWRDN_ENA ; Enable CPU power down automatically.
= 0, DISABLE
= 1, ENABLE

PMU_CPU2_AUTO_PWR_CON = 0x8018 ; CPU2 automatic power control register
> 11, 1, CPU_DBGRCV_NCPUPORESET_ENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, CPU_DBGRCV_NCORERESET_ENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, CPU_ONLY_MEMOFF_ENA ; Enable only power down CPU memory. i.e., just power down memory, but not other digital logic when CPU in OFF mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, CPU_AUTO_EMU_ENA ; Enable CPU emulated off mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_MEM_LS_ENA ; Enable CPU memory light sleep mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, CPU_DBGRCV_ENA ; Enable CPU debug recovery mode by hardware. It is auto cleared when FSM enters debug recovery state.
= 0, DISABLE
= 1, ENABLE

> 4, 1, CPU_AUTO_RET_ENA ; Enable CPU retention mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, CPU_SFT_WAKEUP_ENA ; Enable CPU wake up by software.
= 0, INACTIVE ; Wake up source inactive
= 1, ACTIVE ; Wake up source active

> 1, 1, CPU_INT_WAKEUP_ENA ; Enable interrupt as CPU wake up source.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CPU_AUTO_PWRDN_ENA ; Enable CPU power down automatically.
= 0, DISABLE
= 1, ENABLE

PMU_CPU3_AUTO_PWR_CON = 0x801C ; CPU3 automatic power control register
> 11, 1, CPU_DBGRCV_NCPUPORESET_ENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, CPU_DBGRCV_NCORERESET_ENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, CPU_ONLY_MEMOFF_ENA ; Enable only power down CPU memory. i.e., just power down memory, but not other digital logic when CPU in OFF mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, CPU_AUTO_EMU_ENA ; Enable CPU emulated off mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_MEM_LS_ENA ; Enable CPU memory light sleep mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, CPU_DBGRCV_ENA ; Enable CPU debug recovery mode by hardware. It is auto cleared when FSM enters debug recovery state.
= 0, DISABLE
= 1, ENABLE

> 4, 1, CPU_AUTO_RET_ENA ; Enable CPU retention mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, CPU_SFT_WAKEUP_ENA ; Enable CPU wake up by software.
= 0, INACTIVE ; Wake up source inactive
= 1, ACTIVE ; Wake up source active

> 1, 1, CPU_INT_WAKEUP_ENA ; Enable interrupt as CPU wake up source.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CPU_AUTO_PWRDN_ENA ; Enable CPU power down automatically.
= 0, DISABLE
= 1, ENABLE

PMU_CPU4_AUTO_PWR_CON = 0x8020 ; CPU4 automatic power control register
> 11, 1, CPU_DBGRCV_NCPUPORESET_ENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, CPU_DBGRCV_NCORERESET_ENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, CPU_ONLY_MEMOFF_ENA ; Enable only power down CPU memory. i.e., just power down memory, but not other digital logic when CPU in OFF mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, CPU_AUTO_EMU_ENA ; Enable CPU emulated off mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_MEM_LS_ENA ; Enable CPU memory light sleep mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, CPU_DBGRCV_ENA ; Enable CPU debug recovery mode by hardware. It is auto cleared when FSM enters debug recovery state.
= 0, DISABLE
= 1, ENABLE

> 4, 1, CPU_AUTO_RET_ENA ; Enable CPU retention mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, CPU_SFT_WAKEUP_ENA ; Enable CPU wake up by software.
= 0, INACTIVE ; Wake up source inactive
= 1, ACTIVE ; Wake up source active

> 1, 1, CPU_INT_WAKEUP_ENA ; Enable interrupt as CPU wake up source.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CPU_AUTO_PWRDN_ENA ; Enable CPU power down automatically.
= 0, DISABLE
= 1, ENABLE

PMU_CPU5_AUTO_PWR_CON = 0x8024 ; CPU5 automatic power control register
> 11, 1, CPU_DBGRCV_NCPUPORESET_ENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, CPU_DBGRCV_NCORERESET_ENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, CPU_ONLY_MEMOFF_ENA ; Enable only power down CPU memory. i.e., just power down memory, but not other digital logic when CPU in OFF mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, CPU_AUTO_EMU_ENA ; Enable CPU emulated off mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_MEM_LS_ENA ; Enable CPU memory light sleep mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, CPU_DBGRCV_ENA ; Enable CPU debug recovery mode by hardware. It is auto cleared when FSM enters debug recovery state.
= 0, DISABLE
= 1, ENABLE

> 4, 1, CPU_AUTO_RET_ENA ; Enable CPU retention mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, CPU_SFT_WAKEUP_ENA ; Enable CPU wake up by software.
= 0, INACTIVE ; Wake up source inactive
= 1, ACTIVE ; Wake up source active

> 1, 1, CPU_INT_WAKEUP_ENA ; Enable interrupt as CPU wake up source.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CPU_AUTO_PWRDN_ENA ; Enable CPU power down automatically.
= 0, DISABLE
= 1, ENABLE

PMU_CPU6_AUTO_PWR_CON = 0x8028 ; CPU6 automatic power control register
> 11, 1, CPU_DBGRCV_NCPUPORESET_ENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, CPU_DBGRCV_NCORERESET_ENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, CPU_ONLY_MEMOFF_ENA ; Enable only power down CPU memory. i.e., just power down memory, but not other digital logic when CPU in OFF mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, CPU_AUTO_EMU_ENA ; Enable CPU emulated off mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_MEM_LS_ENA ; Enable CPU memory light sleep mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, CPU_DBGRCV_ENA ; Enable CPU debug recovery mode by hardware. It is auto cleared when FSM enters debug recovery state.
= 0, DISABLE
= 1, ENABLE

> 4, 1, CPU_AUTO_RET_ENA ; Enable CPU retention mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, CPU_SFT_WAKEUP_ENA ; Enable CPU wake up by software.
= 0, INACTIVE ; Wake up source inactive
= 1, ACTIVE ; Wake up source active

> 1, 1, CPU_INT_WAKEUP_ENA ; Enable interrupt as CPU wake up source.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CPU_AUTO_PWRDN_ENA ; Enable CPU power down automatically.
= 0, DISABLE
= 1, ENABLE

PMU_CPU7_AUTO_PWR_CON = 0x802C ; CPU7 automatic power control register
> 11, 1, CPU_DBGRCV_NCPUPORESET_ENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, CPU_DBGRCV_NCORERESET_ENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, CPU_ONLY_MEMOFF_ENA ; Enable only power down CPU memory. i.e., just power down memory, but not other digital logic when CPU in OFF mode.
= 0, DISABLE
= 1, ENABLE

> 8, 1, CPU_AUTO_EMU_ENA ; Enable CPU emulated off mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_MEM_LS_ENA ; Enable CPU memory light sleep mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, CPU_DBGRCV_ENA ; Enable CPU debug recovery mode by hardware. It is auto cleared when FSM enters debug recovery state.
= 0, DISABLE
= 1, ENABLE

> 4, 1, CPU_AUTO_RET_ENA ; Enable CPU retention mode by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, CPU_SFT_WAKEUP_ENA ; Enable CPU wake up by software.
= 0, INACTIVE ; Wake up source inactive
= 1, ACTIVE ; Wake up source active

> 1, 1, CPU_INT_WAKEUP_ENA ; Enable interrupt as CPU wake up source.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CPU_AUTO_PWRDN_ENA ; Enable CPU power down automatically.
= 0, DISABLE
= 1, ENABLE

PMU_CPU0_PWR_SFTCON = 0x8030 ; CPU0 software power control register
> 8, 1, CPU_MEM_LS_SFTENA ; Enable CPU memory light sleep mode by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_DBGRCV_NCPUPORESET_SFTENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 6, 1, CPU_DBGRCV_NCORERESET_SFTENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 5, 1, CPU_SFT_PACTIVE_DBGRCV ; PACTIVE bit generated by software when requested mode is debug recovery mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 4, 1, CPU_SFT_PACTIVE_EMUOFF ; PACTIVE bit generated by software when requested mode is emulated off mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 3, 1, CPU_SFT_PACTIVE_RET ; PACTIVE bit generated by software when requested mode is retention mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 2, 1, CPU_SFT_PACTIVE_ON ; PACTIVE bit generated by software when requested mode is ON mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 1, 1, CPU_SFT_PACTIVE_OFF ; PACTIVE bit generated by software when requested mode is OFF mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 0, 1, CPU_PWRDN_SFTENA ; Enable CPU power down by software.
= 0, DISABLE
= 1, ENABLE

PMU_CPU1_PWR_SFTCON = 0x8034 ; CPU1 software power control register
> 8, 1, CPU_MEM_LS_SFTENA ; Enable CPU memory light sleep mode by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_DBGRCV_NCPUPORESET_SFTENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 6, 1, CPU_DBGRCV_NCORERESET_SFTENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 5, 1, CPU_SFT_PACTIVE_DBGRCV ; PACTIVE bit generated by software when requested mode is debug recovery mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 4, 1, CPU_SFT_PACTIVE_EMUOFF ; PACTIVE bit generated by software when requested mode is emulated off mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 3, 1, CPU_SFT_PACTIVE_RET ; PACTIVE bit generated by software when requested mode is retention mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 2, 1, CPU_SFT_PACTIVE_ON ; PACTIVE bit generated by software when requested mode is ON mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 1, 1, CPU_SFT_PACTIVE_OFF ; PACTIVE bit generated by software when requested mode is OFF mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 0, 1, CPU_PWRDN_SFTENA ; Enable CPU power down by software.
= 0, DISABLE
= 1, ENABLE

PMU_CPU2_PWR_SFTCON = 0x8038 ; CPU2 software power control register
> 8, 1, CPU_MEM_LS_SFTENA ; Enable CPU memory light sleep mode by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_DBGRCV_NCPUPORESET_SFTENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 6, 1, CPU_DBGRCV_NCORERESET_SFTENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 5, 1, CPU_SFT_PACTIVE_DBGRCV ; PACTIVE bit generated by software when requested mode is debug recovery mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 4, 1, CPU_SFT_PACTIVE_EMUOFF ; PACTIVE bit generated by software when requested mode is emulated off mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 3, 1, CPU_SFT_PACTIVE_RET ; PACTIVE bit generated by software when requested mode is retention mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 2, 1, CPU_SFT_PACTIVE_ON ; PACTIVE bit generated by software when requested mode is ON mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 1, 1, CPU_SFT_PACTIVE_OFF ; PACTIVE bit generated by software when requested mode is OFF mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 0, 1, CPU_PWRDN_SFTENA ; Enable CPU power down by software.
= 0, DISABLE
= 1, ENABLE

PMU_CPU3_PWR_SFTCON = 0x803C ; CPU3 software power control register
> 8, 1, CPU_MEM_LS_SFTENA ; Enable CPU memory light sleep mode by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_DBGRCV_NCPUPORESET_SFTENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 6, 1, CPU_DBGRCV_NCORERESET_SFTENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 5, 1, CPU_SFT_PACTIVE_DBGRCV ; PACTIVE bit generated by software when requested mode is debug recovery mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 4, 1, CPU_SFT_PACTIVE_EMUOFF ; PACTIVE bit generated by software when requested mode is emulated off mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 3, 1, CPU_SFT_PACTIVE_RET ; PACTIVE bit generated by software when requested mode is retention mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 2, 1, CPU_SFT_PACTIVE_ON ; PACTIVE bit generated by software when requested mode is ON mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 1, 1, CPU_SFT_PACTIVE_OFF ; PACTIVE bit generated by software when requested mode is OFF mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 0, 1, CPU_PWRDN_SFTENA ; Enable CPU power down by software.
= 0, DISABLE
= 1, ENABLE

PMU_CPU4_PWR_SFTCON = 0x8040 ; CPU4 software power control register
> 8, 1, CPU_MEM_LS_SFTENA ; Enable CPU memory light sleep mode by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_DBGRCV_NCPUPORESET_SFTENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 6, 1, CPU_DBGRCV_NCORERESET_SFTENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 5, 1, CPU_SFT_PACTIVE_DBGRCV ; PACTIVE bit generated by software when requested mode is debug recovery mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 4, 1, CPU_SFT_PACTIVE_EMUOFF ; PACTIVE bit generated by software when requested mode is emulated off mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 3, 1, CPU_SFT_PACTIVE_RET ; PACTIVE bit generated by software when requested mode is retention mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 2, 1, CPU_SFT_PACTIVE_ON ; PACTIVE bit generated by software when requested mode is ON mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 1, 1, CPU_SFT_PACTIVE_OFF ; PACTIVE bit generated by software when requested mode is OFF mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 0, 1, CPU_PWRDN_SFTENA ; Enable CPU power down by software.
= 0, DISABLE
= 1, ENABLE

PMU_CPU5_PWR_SFTCON = 0x8044 ; CPU5 software power control register
> 8, 1, CPU_MEM_LS_SFTENA ; Enable CPU memory light sleep mode by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_DBGRCV_NCPUPORESET_SFTENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 6, 1, CPU_DBGRCV_NCORERESET_SFTENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 5, 1, CPU_SFT_PACTIVE_DBGRCV ; PACTIVE bit generated by software when requested mode is debug recovery mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 4, 1, CPU_SFT_PACTIVE_EMUOFF ; PACTIVE bit generated by software when requested mode is emulated off mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 3, 1, CPU_SFT_PACTIVE_RET ; PACTIVE bit generated by software when requested mode is retention mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 2, 1, CPU_SFT_PACTIVE_ON ; PACTIVE bit generated by software when requested mode is ON mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 1, 1, CPU_SFT_PACTIVE_OFF ; PACTIVE bit generated by software when requested mode is OFF mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 0, 1, CPU_PWRDN_SFTENA ; Enable CPU power down by software.
= 0, DISABLE
= 1, ENABLE

PMU_CPU6_PWR_SFTCON = 0x8048 ; CPU6 software power control register
> 8, 1, CPU_MEM_LS_SFTENA ; Enable CPU memory light sleep mode by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_DBGRCV_NCPUPORESET_SFTENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 6, 1, CPU_DBGRCV_NCORERESET_SFTENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 5, 1, CPU_SFT_PACTIVE_DBGRCV ; PACTIVE bit generated by software when requested mode is debug recovery mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 4, 1, CPU_SFT_PACTIVE_EMUOFF ; PACTIVE bit generated by software when requested mode is emulated off mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 3, 1, CPU_SFT_PACTIVE_RET ; PACTIVE bit generated by software when requested mode is retention mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 2, 1, CPU_SFT_PACTIVE_ON ; PACTIVE bit generated by software when requested mode is ON mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 1, 1, CPU_SFT_PACTIVE_OFF ; PACTIVE bit generated by software when requested mode is OFF mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 0, 1, CPU_PWRDN_SFTENA ; Enable CPU power down by software.
= 0, DISABLE
= 1, ENABLE

PMU_CPU7_PWR_SFTCON = 0x804C ; CPU7 software power control register
> 8, 1, CPU_MEM_LS_SFTENA ; Enable CPU memory light sleep mode by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU_DBGRCV_NCPUPORESET_SFTENA ; Enable CPU enters cold reset by assert ncpureset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 6, 1, CPU_DBGRCV_NCORERESET_SFTENA ; Enable CPU enters warm reset by assert ncorereset when CPU in debug recovery mode by software.
= 0, ENABLE
= 1, DISABLE

> 5, 1, CPU_SFT_PACTIVE_DBGRCV ; PACTIVE bit generated by software when requested mode is debug recovery mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 4, 1, CPU_SFT_PACTIVE_EMUOFF ; PACTIVE bit generated by software when requested mode is emulated off mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 3, 1, CPU_SFT_PACTIVE_RET ; PACTIVE bit generated by software when requested mode is retention mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 2, 1, CPU_SFT_PACTIVE_ON ; PACTIVE bit generated by software when requested mode is ON mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 1, 1, CPU_SFT_PACTIVE_OFF ; PACTIVE bit generated by software when requested mode is OFF mode. High active. It is auto cleared when PREQ is active. It is used when CPU power mode transition is controlled by software.
= 1, ACTIVE

> 0, 1, CPU_PWRDN_SFTENA ; Enable CPU power down by software.
= 0, DISABLE
= 1, ENABLE

PMU_CORE0_PWR_CON = 0x8050 ; BIGCORE0 hardware power control register
> 3, 1, CORE_PWR_CNT_ENA ; Enable counter to wait for VD_BIGCORE0 power on or power off stability.
= 0, DISABLE
= 1, ENABLE

> 2, 1, CORE_CPU_PWRDN_ENA ; Enable CPU power down when VD_BIGCORE0 power down by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, CORE_PWROFF_ENA ; Enable VD_BIGCORE0 power off by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CORE_PWRDN_ENA ; Enable VD_BIGCORE0 power down by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_CORE1_PWR_CON = 0x8054 ; BIGCORE1 hardware power control register
> 3, 1, CORE_PWR_CNT_ENA ; Enable counter to wait for VD_BIGCORE1 power on or power off stability.
= 0, DISABLE
= 1, ENABLE

> 2, 1, CORE_CPU_PWRDN_ENA ; Enable CPU power down when VD_BIGCORE1 power down by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, CORE_PWROFF_ENA ; Enable VD_BIGCORE1 power off by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CORE_PWRDN_ENA ; Enable VD_BIGCORE1 power down by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_CORE0_PWR_SFTCON = 0x8058 ; BIGCORE0 software power control register
> 3, 1, CORE_DWN_ACK_CLAMP_ENA ; Enable clamp for VD_BIGCORE0 power down acknowledge. This bit should be set to 1 if VD_BIGCORE0 power off.
= 0, DISABLE
= 1, ENABLE

> 2, 1, CORE_CPU_PWRDN_SFTENA ; Enable CPU power down when VD_BIGCORE0 power down by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, CORE_PWROFF_SFTENA ; Enable VD_BIGCORE0 power off by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CORE_PWRDN_SFTENA ; Enable VD_BIGCORE0 power down by software.
= 0, DISABLE
= 1, ENABLE

PMU_CORE1_PWR_SFTCON = 0x805C ; BIGCORE1 software power control register
> 3, 1, CORE_DWN_ACK_CLAMP_ENA ; Enable clamp for VD_BIGCORE1 power down acknowledge. This bit should be set to 1 if VD_BIGCORE1 power off.
= 0, DISABLE
= 1, ENABLE

> 2, 1, CORE_CPU_PWRDN_SFTENA ; Enable CPU power down when VD_BIGCORE1 power down by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, CORE_PWROFF_SFTENA ; Enable VD_BIGCORE1 power off by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CORE_PWRDN_SFTENA ; Enable VD_BIGCORE1 power down by software.
= 0, DISABLE
= 1, ENABLE

PMU_CORE0_AUTO_PWR_CON = 0x8060 ; BIGCORE0 automatic power control register
> 3, 1, CORE_INT_WAKEUP_SFTENA ; Enable VD_BIGCORE0 wake up by software.
= 0, INACTIVE ; Wake up source inactive
= 1, ACTIVE ; Wake up source active

> 1, 1, CORE_INT_WAKEUP_ENA ; Enable interrupt as VD_BIGCORE0 wake up source.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CORE_LP_EN ; Enable VD_BIGCORE0 low power mode.
= 0, DISABLE
= 1, ENABLE

PMU_CORE1_AUTO_PWR_CON = 0x8064 ; BIGCORE1 automatic power control register
> 3, 1, CORE_INT_WAKEUP_SFTENA ; Enable VD_BIGCORE1 wake up by software.
= 0, INACTIVE ; Wake up source inactive
= 1, ACTIVE ; Wake up source active

> 1, 1, CORE_INT_WAKEUP_ENA ; Enable interrupt as VD_BIGCORE1 wake up source.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CORE_LP_EN ; Enable VD_BIGCORE1 low power mode.
= 0, DISABLE
= 1, ENABLE

PMU_CLUSTER_BIU_AUTO_CON = 0x8068 ; Cluster BIU automatic power control register
> 3, 1, BIU_AUTO_LITDSU_ENA ; If enable, BIU_LITDSU corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 2, 1, BIU_AUTO_DSU_ENA ; If enable, BIU_DSU corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 1, 1, BIU_AUTO_BIGCORE1_ENA ; If enable, BIU_BIGCORE1 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 0, 1, BIU_AUTO_BIGCORE0_ENA ; If enable, BIU_BIGCORE0 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

PMU_CLUSTER_BIU_IDLE_CON = 0x8070 ; Cluster BIU idle request hardware control register
> 6, 1, ADB400_CORE_QCH_ENA ; Enable core ADB400 Q-Channel power control by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, IDLE_REQ_LITDSU_ENA ; Enable sending idle request to BIU_LITDSU by hardware.
= 0, DISABLE
= 1, ENABLE

> 4, 1, IDLE_REQ_DSU_ENA ; Enable sending idle request to BIU_DSU by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, IDLE_REQ_BIGCORE1_ENA ; Enable sending idle request to BIU_BIGCORE1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, IDLE_REQ_BIGCORE0_ENA ; Enable sending idle request to BIU_BIGCORE0 by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_CLUSTER_BIU_IDLE_SFTCON = 0x8074 ; Cluster BIU idle request software control register
> 6, 1, ADB400_CORE_QCH_SFTENA ; Enable core ADB400 Q-Channel power control by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, IDLE_REQ_LITDSU_SFTENA ; Enable sending idle request to BIU_LITDSU by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, IDLE_REQ_DSU_SFTENA ; Enable sending idle request to BIU_DSU by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, IDLE_REQ_BIGCORE1_SFTENA ; Enable sending idle request to BIU_BIGCORE1 by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, IDLE_REQ_BIGCORE0_SFTENA ; Enable sending idle request to BIU_BIGCORE0 by software.
= 0, DISABLE
= 1, ENABLE

PMU_CLUSTER_BIU_IDLE_ACK_STS = 0x8078 ; Cluster BIU idle acknowledge status register
> 4, 1, ADB400_CORE_PACCEPT, RO ; PACCEPT state from core ADB400.
= 0, INACTIVE
= 1, ACTIVE

> 3, 1, IDLE_ACK_LITDSU, RO ; BIU_LITDSU idle acknowledge state.
= 0, NAK
= 1, ACK

> 2, 1, IDLE_ACK_DSU, RO ; BIU_DSU idle acknowledge state.
= 0, NAK
= 1, ACK

> 1, 1, IDLE_ACK_BIGCORE1, RO ; BIU_BIGCORE1 idle acknowledge state.
= 0, NAK
= 1, ACK

> 0, 1, IDLE_ACK_BIGCORE0, RO ; BIU_BIGCORE0 idle acknowledge state.
= 0, NAK
= 1, ACK

PMU_CLUSTER_BIU_IDLE_STS = 0x807C ; Cluster BIU idle status register
> 4, 1, ADB400_CORE_PACTIVE, RO ; PACTIVE state from core ADB400.
= 0, INACTIVE
= 1, ACTIVE

> 3, 1, IDLE_LITDSU, RO ; BIU_LITDSU idle state.
= 0, NOT_IDLE
= 1, IDLE

> 2, 1, IDLE_DSU, RO ; BIU_DSU idle state.
= 0, NOT_IDLE
= 1, IDLE

> 1, 1, IDLE_BIGCORE1, RO ; BIU_BIGCORE1 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 0, 1, IDLE_BIGCORE0, RO ; BIU_BIGCORE0 idle state.
= 0, NOT_IDLE
= 1, IDLE

PMU_CLUSTER_STS = 0x8080 ; Cluster status register
> 27, 1, CPU7_STANDBYWFI, RO ; CPU7 standbywfi state.
= 0, NOT ; Not standbywfi
= 1, STANDBY ; Standbywfi

> 26, 1, CPU6_STANDBYWFI, RO ; CPU6 standbywfi state.
= 0, NOT ; Not standbywfi
= 1, STANDBY ; Standbywfi

> 25, 1, CPU5_STANDBYWFI, RO ; CPU5 standbywfi state.
= 0, NOT ; Not standbywfi
= 1, STANDBY ; Standbywfi

> 24, 1, CPU4_STANDBYWFI, RO ; CPU4 standbywfi state.
= 0, NOT ; Not standbywfi
= 1, STANDBY ; Standbywfi

> 23, 1, CPU3_STANDBYWFI, RO ; CPU3 standbywfi state.
= 0, NOT ; Not standbywfi
= 1, STANDBY ; Standbywfi

> 22, 1, CPU2_STANDBYWFI, RO ; CPU2 standbywfi state.
= 0, NOT ; Not standbywfi
= 1, STANDBY ; Standbywfi

> 21, 1, CPU1_STANDBYWFI, RO ; CPU1 standbywfi state.
= 0, NOT ; Not standbywfi
= 1, STANDBY ; Standbywfi

> 20, 1, CPU0_STANDBYWFI, RO ; CPU0 standbywfi state.
= 0, NOT ; Not standbywfi
= 1, STANDBY ; Standbywfi

> 19, 1, DSU_HANDSHAKE, RO ; DSU P-Channel hand shake state. If P-Channel request is accepted, it is set to 1; If P-Channel request is denied, it is set to 0.
= 0, NOT_HAND_SHAKE
= 1, HAND_SHAKE

> 18, 1, CPU7_HANDSHAKE, RO ; CPU7 P-Channel hand shake state. If P-Channel request is accepted, it is set to 1; If P-Channel request is denied, it is set to 0.
= 0, NOT_HAND_SHAKE
= 1, HAND_SHAKE

> 17, 1, CPU6_HANDSHAKE, RO ; CPU6 P-Channel hand shake state. If P-Channel request is accepted, it is set to 1; If P-Channel request is denied, it is set to 0.
= 0, NOT_HAND_SHAKE
= 1, HAND_SHAKE

> 16, 1, CPU5_HANDSHAKE, RO ; CPU5 P-Channel hand shake state. If P-Channel request is accepted, it is set to 1; If P-Channel request is denied, it is set to 0.
= 0, NOT_HAND_SHAKE
= 1, HAND_SHAKE

> 15, 1, CPU4_HANDSHAKE, RO ; CPU4 P-Channel hand shake state. If P-Channel request is accepted, it is set to 1; If P-Channel request is denied, it is set to 0.
= 0, NOT_HAND_SHAKE
= 1, HAND_SHAKE

> 14, 1, CPU3_HANDSHAKE, RO ; CPU3 P-Channel hand shake state. If P-Channel request is accepted, it is set to 1; If P-Channel request is denied, it is set to 0.
= 0, NOT_HAND_SHAKE
= 1, HAND_SHAKE

> 13, 1, CPU2_HANDSHAKE, RO ; CPU2 P-Channel hand shake state. If P-Channel request is accepted, it is set to 1; If P-Channel request is denied, it is set to 0.
= 0, NOT_HAND_SHAKE
= 1, HAND_SHAKE

> 12, 1, CPU1_HANDSHAKE, RO ; CPU1 P-Channel hand shake state. If P-Channel request is accepted, it is set to 1; If P-Channel request is denied, it is set to 0.
= 0, NOT_HAND_SHAKE
= 1, HAND_SHAKE

> 11, 1, CPU0_HANDSHAKE, RO ; CPU0 P-Channel hand shake state. If P-Channel request is accepted, it is set to 1; If P-Channel request is denied, it is set to 0.
= 0, NOT_HAND_SHAKE
= 1, HAND_SHAKE

> 10, 1, PD_DSU_DWN_STAT, RO ; VD_LITDSU power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 9, 1, PD_CORE1_DWN_STAT, RO ; VD_BIGCORE1 power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 8, 1, PD_CORE0_DWN_STAT, RO ; VD_BIGCORE0 power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 7, 1, PD_CPU7_DWN_STAT, RO ; PD_CPU7 power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 6, 1, PD_CPU6_DWN_STAT, RO ; PD_CPU6 power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 5, 1, PD_CPU5_DWN_STAT, RO ; PD_CPU5 power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 4, 1, PD_CPU4_DWN_STAT, RO ; PD_CPU4 power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 3, 1, PD_CPU3_DWN_STAT, RO ; PD_CPU3 power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 2, 1, PD_CPU2_DWN_STAT, RO ; PD_CPU2 power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 1, 1, PD_CPU1_DWN_STAT, RO ; PD_CPU1 power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 0, 1, PD_CPU0_DWN_STAT, RO ; PD_CPU0 power state.
= 0, POWER_UP
= 1, POWER_DOWN

PMU_CLUSTER_POWER_STS0 = 0x8084 ; Cluster power status register 0
> 28, 3, CPU7_POWER_STATE ; CPU7 power state.
= 0, _ ; Normal state
= 1, _ ; Off state
= 2, _ ; Emulated off state
= 3, _ ; Retention state
= 4, _ ; Debug recovery state

> 24, 3, CPU6_POWER_STATE, RO ; CPU6 power state.
= 0, _ ; Normal state
= 1, _ ; Off state
= 2, _ ; Emulated off state
= 3, _ ; Retention state
= 4, _ ; Debug recovery state

> 20, 3, CPU5_POWER_STATE, RO ; CPU5 power state.
= 0, _ ; Normal state
= 1, _ ; Off state
= 2, _ ; Emulated off state
= 3, _ ; Retention state
= 4, _ ; Debug recovery state

> 16, 3, CPU4_POWER_STATE, RO ; CPU4 power state.
= 0, _ ; Normal state
= 1, _ ; Off state
= 2, _ ; Emulated off state
= 3, _ ; Retention state
= 4, _ ; Debug recovery state

> 12, 3, CPU3_POWER_STATE, RO ; CPU3 power state.
= 0, _ ; Normal state
= 1, _ ; Off state
= 2, _ ; Emulated off state
= 3, _ ; Retention state
= 4, _ ; Debug recovery state

> 8, 3, CPU2_POWER_STATE, RO ; CPU2 power state.
= 0, _ ; Normal state
= 1, _ ; Off state
= 2, _ ; Emulated off state
= 3, _ ; Retention state
= 4, _ ; Debug recovery state

> 4, 3, CPU1_POWER_STATE, RO ; CPU1 power state.
= 0, _ ; Normal state
= 1, _ ; Off state
= 2, _ ; Emulated off state
= 3, _ ; Retention state
= 4, _ ; Debug recovery state

> 0, 3, CPU0_POWER_STATE, RO ; CPU0 power state.
= 0, _ ; Normal state
= 1, _ ; Off state
= 2, _ ; Emulated off state
= 3, _ ; Retention state
= 4, _ ; Debug recovery state

PMU_CLUSTER_POWER_STS1 = 0x8088 ; Cluster power status register 1
> 8, 4, DSU_POWER_STATE, RO ; DSU power state.
= 0, _ ; Normal state
= 1, _ ; DSU transfer idle state
= 2, _ ; DSU power down state
= 3, _ ; DSU sleep state
= 4, _ ; DSU wake up state
= 5, _ ; DSU power up state
= 6, _ ; DSU transfer resume state
= 7, _ ; DSU FUNC_RET state
= 8, _ ; DSU 3/4 ON state
= 9, _ ; DSU 1/2 ON state
= 10, _ ; DSU 1/4 ON state
= 11, _ ; DSU SFONLY ON state
= 12, _ ; DSU 3/4 FUNC_RET state
= 13, _ ; DSU 1/2 FUNC_RET state
= 14, _ ; DSU 1/4 FUNC_RET state
= 15, _ ; DSU SFONLY FUNC_RET state

> 4, 4, CORE1_POWER_STATE, RO ; BIGCORE1 power state.
= 0, _ ; Normal state
= 1, _ ; CPU power down state
= 2, _ ; Core transfer idle state
= 3, _ ; Core power down state
= 4, _ ; Core sleep state
= 5, _ ; Core wake up state
= 6, _ ; Core power up state
= 7, _ ; Core transfer resume state
= 8, _ ; CPU power up state

> 0, 4, CORE0_POWER_STATE, RO ; BIGCORE0 power state.
= 0, _ ; Normal state
= 1, _ ; CPU power down state
= 2, _ ; Core transfer idle state
= 3, _ ; Core power down state
= 4, _ ; Core sleep state
= 5, _ ; Core wake up state
= 6, _ ; Core power up state
= 7, _ ; Core transfer resume state
= 8, _ ; CPU power up state

PMU_CLUSTER_PCHANNEL_STS0 = 0x808C ; Cluster P-Channel status register 0
> 29, 1, CPU3_PDENY, RO ; CPU3 P-Channel status.
= 1, ACTIVE

> 28, 1, CPU3_PACCEPT, RO ; CPU3 P-Channel status.
= 1, ACTIVE

> 27, 1, CPU3_PACTIVE8, RO ; CPU3 P-Channel status.
= 1, ACTIVE

> 26, 1, CPU3_PACTIVE7, RO ; CPU3 P-Channel status.
= 1, ACTIVE

> 25, 1, CPU3_PACTIVE5, RO ; CPU3 P-Channel status.
= 1, ACTIVE

> 24, 1, CPU3_PACTIVE1, RO ; CPU3 P-Channel status.
= 1, ACTIVE

> 21, 1, CPU2_PDENY, RO ; CPU2 P-Channel status.
= 1, ACTIVE

> 20, 1, CPU2_PACCEPT, RO ; CPU2 P-Channel status.
= 1, ACTIVE

> 19, 1, CPU2_PACTIVE8, RO ; CPU2 P-Channel status.
= 1, ACTIVE

> 18, 1, CPU2_PACTIVE7, RO ; CPU2 P-Channel status.
= 1, ACTIVE

> 17, 1, CPU2_PACTIVE5, RO ; CPU2 P-Channel status.
= 1, ACTIVE

> 16, 1, CPU2_PACTIVE1, RO ; CPU2 P-Channel status.
= 1, ACTIVE

> 13, 1, CPU1_PDENY, RO ; CPU1 P-Channel status.
= 1, ACTIVE

> 12, 1, CPU1_PACCEPT, RO ; CPU1 P-Channel status.
= 1, ACTIVE

> 11, 1, CPU1_PACTIVE8, RO ; CPU1 P-Channel status.
= 1, ACTIVE

> 10, 1, CPU1_PACTIVE7, RO ; CPU1 P-Channel status.
= 1, ACTIVE

> 9, 1, CPU1_PACTIVE5, RO ; CPU1 P-Channel status.
= 1, ACTIVE

> 8, 1, CPU1_PACTIVE1, RO ; CPU1 P-Channel status.
= 1, ACTIVE

> 5, 1, CPU0_PDENY, RO ; CPU0 P-Channel status.
= 1, ACTIVE

> 4, 1, CPU0_PACCEPT, RO ; CPU0 P-Channel status.
= 1, ACTIVE

> 3, 1, CPU0_PACTIVE8, RO ; CPU0 P-Channel status.
= 1, ACTIVE

> 2, 1, CPU0_PACTIVE7, RO ; CPU0 P-Channel status.
= 1, ACTIVE

> 1, 1, CPU0_PACTIVE5, RO ; CPU0 P-Channel status.
= 1, ACTIVE

> 0, 1, CPU0_PACTIVE1, RO ; CPU0 P-Channel status.
= 1, ACTIVE

PMU_CLUSTER_PCHANNEL_STS1 = 0x8090 ; Cluster P-Channel status register 1
> 29, 1, CPU7_PDENY, RO ; CPU7 P-Channel status.
= 1, ACTIVE

> 28, 1, CPU7_PACCEPT, RO ; CPU7 P-Channel status.
= 1, ACTIVE

> 27, 1, CPU7_PACTIVE8, RO ; CPU7 P-Channel status.
= 1, ACTIVE

> 26, 1, CPU7_PACTIVE7, RO ; CPU7 P-Channel status.
= 1, ACTIVE

> 25, 1, CPU7_PACTIVE5, RO ; CPU7 P-Channel status.
= 1, ACTIVE

> 24, 1, CPU7_PACTIVE1, RO ; CPU7 P-Channel status.
= 1, ACTIVE

> 21, 1, CPU6_PDENY, RO ; CPU6 P-Channel status.
= 1, ACTIVE

> 20, 1, CPU6_PACCEPT, RO ; CPU6 P-Channel status.
= 1, ACTIVE

> 19, 1, CPU6_PACTIVE8, RO ; CPU6 P-Channel status.
= 1, ACTIVE

> 18, 1, CPU6_PACTIVE7, RO ; CPU6 P-Channel status.
= 1, ACTIVE

> 17, 1, CPU6_PACTIVE5, RO ; CPU6 P-Channel status.
= 1, ACTIVE

> 16, 1, CPU6_PACTIVE1, RO ; CPU6 P-Channel status.
= 1, ACTIVE

> 13, 1, CPU5_PDENY, RO ; CPU5 P-Channel status.
= 1, ACTIVE

> 12, 1, CPU5_PACCEPT, RO ; CPU5 P-Channel status.
= 1, ACTIVE

> 11, 1, CPU5_PACTIVE8, RO ; CPU5 P-Channel status.
= 1, ACTIVE

> 10, 1, CPU5_PACTIVE7, RO ; CPU5 P-Channel status.
= 1, ACTIVE

> 9, 1, CPU5_PACTIVE5, RO ; CPU5 P-Channel status.
= 1, ACTIVE

> 8, 1, CPU5_PACTIVE1, RO ; CPU5 P-Channel status.
= 1, ACTIVE

> 5, 1, CPU4_PDENY, RO ; CPU4 P-Channel status.
= 1, ACTIVE

> 4, 1, CPU4_PACCEPT, RO ; CPU4 P-Channel status.
= 1, ACTIVE

> 3, 1, CPU4_PACTIVE8, RO ; CPU4 P-Channel status.
= 1, ACTIVE

> 2, 1, CPU4_PACTIVE7, RO ; CPU4 P-Channel status.
= 1, ACTIVE

> 1, 1, CPU4_PACTIVE5, RO ; CPU4 P-Channel status.
= 1, ACTIVE

> 0, 1, CPU4_PACTIVE1, RO ; CPU4 P-Channel status.
= 1, ACTIVE

PMU_CLUSTER_PCHANNEL_STS2 = 0x8094 ; Cluster P-Channel status register 2
> 8, 1, CLUSTERPDENY, RO ; DSU P-Channel status.
= 1, ACTIVE

> 7, 1, CLUSTERPACCEPT, RO ; DSU P-Channel status.
= 1, ACTIVE

> 6, 1, CLUSTERPACTIVE19, RO ; DSU P-Channel status.
= 1, ACTIVE

> 5, 1, CLUSTERPACTIVE18, RO ; DSU P-Channel status.
= 1, ACTIVE

> 4, 1, CLUSTERPACTIVE17, RO ; DSU P-Channel status.
= 1, ACTIVE

> 3, 1, CLUSTERPACTIVE16, RO ; DSU P-Channel status.
= 1, ACTIVE

> 2, 1, CLUSTERPACTIVE8, RO ; DSU P-Channel status.
= 1, ACTIVE

> 1, 1, CLUSTERPACTIVE7, RO ; DSU P-Channel status.
= 1, ACTIVE

> 0, 1, CLUSTERPACTIVE2, RO ; DSU P-Channel status.
= 1, ACTIVE

PMU_CPU_PWR_CHAIN_STABLE_CON = 0x8098 ; CPU power chain stable control register
> 15, 1, CPU7_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_CPU7 power down flow.
= 0, DISABLE
= 1, ENABLE

> 14, 1, CPU6_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_CPU6 power down flow.
= 0, DISABLE
= 1, ENABLE

> 13, 1, CPU5_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_CPU5 power down flow.
= 0, DISABLE
= 1, ENABLE

> 12, 1, CPU4_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_CPU4 power down flow.
= 0, DISABLE
= 1, ENABLE

> 11, 1, CPU3_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_CPU3 power down flow.
= 0, DISABLE
= 1, ENABLE

> 10, 1, CPU2_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_CPU2 power down flow.
= 0, DISABLE
= 1, ENABLE

> 9, 1, CPU1_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_CPU1 power down flow.
= 0, DISABLE
= 1, ENABLE

> 8, 1, CPU0_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_CPU0 power down flow.
= 0, DISABLE
= 1, ENABLE

> 7, 1, CPU7_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_CPU7 power up flow.
= 0, DISABLE
= 1, ENABLE

> 6, 1, CPU6_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_CPU6 power up flow.
= 0, DISABLE
= 1, ENABLE

> 5, 1, CPU5_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_CPU5 power up flow.
= 0, DISABLE
= 1, ENABLE

> 4, 1, CPU4_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_CPU4 power up flow.
= 0, DISABLE
= 1, ENABLE

> 3, 1, CPU3_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_CPU3 power up flow.
= 0, DISABLE
= 1, ENABLE

> 2, 1, CPU2_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_CPU2 power up flow.
= 0, DISABLE
= 1, ENABLE

> 1, 1, CPU1_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_CPU1 power up flow.
= 0, DISABLE
= 1, ENABLE

> 0, 1, CPU0_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_CPU0 power up flow.
= 0, DISABLE
= 1, ENABLE

PMU_DSU_MEM_PWR_CON = 0x809C ; DSU memory power control register
# 12, 4, DSU_MEM_LS_SFTENA ; Enable DSU memory enters light sleep mode by software.
> 15, 1, DSU_MEM_LS_SFTENA3 ; used to light sleep "L3 Tag ways 8~11, L3 Data portion 1 RAMs".
= 0, DISABLE
= 1, ENABLE

> 14, 1, DSU_MEM_LS_SFTENA2 ; used to light sleep "L3 Tag ways 4~7".
= 0, DISABLE
= 1, ENABLE

> 13, 1, DSU_MEM_LS_SFTENA1 ; used to light sleep "L3 Tag ways 0~3, L3 Data portion 0, and L3 Victim RAMs".
= 0, DISABLE
= 1, ENABLE

> 12, 1, DSU_MEM_LS_SFTENA0 ; used to light sleep "Snoop filter and LTDB RAMs".
= 0, DISABLE
= 1, ENABLE

# 8, 4, DSU_MEM_SD_SFTENA ; Enable DSU memory enters shutdown mode by software.
> 11, 1, DSU_MEM_SD_SFTENA3; used to shutdown "L3 Tag ways 8~11, L3 Data portion 1 RAMs".
= 0, DISABLE
= 1, ENABLE

> 10, 1, DSU_MEM_SD_SFTENA2; used to shutdown "L3 Tag ways 4~7".
= 0, DISABLE
= 1, ENABLE

> 9, 1, DSU_MEM_SD_SFTENA1; used to shutdown "L3 Tag ways 0~3, L3 Data portion 0, and L3 Victim RAMs".
= 0, DISABLE
= 1, ENABLE

> 8, 1, DSU_MEM_SD_SFTENA0; used to shutdown "Snoop filter and LTDB RAMs".
= 0, DISABLE
= 1, ENABLE

# 4, 4, DSU_MEM_LS_ENA ; Enable DSU memory enters light sleep mode by hardware.
> 7, 1, DSU_MEM_LS_ENA3 ; used to light sleep "L3 Tag ways 8~11, L3 Data portion 1 RAMs".
= 0, DISABLE
= 1, ENABLE

> 6, 1, DSU_MEM_LS_ENA2 ; used to light sleep "L3 Tag ways 4~7".
= 0, DISABLE
= 1, ENABLE

> 5, 1, DSU_MEM_LS_ENA1 ; used to light sleep "L3 Tag ways 0~3, L3 Data portion 0, and L3 Victim RAMs".
= 0, DISABLE
= 1, ENABLE

> 4, 1, DSU_MEM_LS_ENA0 ; used to light sleep "Snoop filter and LTDB RAMs".
= 0, DISABLE
= 1, ENABLE

# 0, 4, DSU_MEM_SD_ENA ; Enable DSU memory enters shutdown mode by hardware.
> 3, 1, DSU_MEM_SD_ENA3 ; used to shutdown "L3 Tag ways 8~11, L3 Data portion 1 RAMs".
= 0, DISABLE
= 1, ENABLE

> 2, 1, DSU_MEM_SD_ENA2 ; used to shutdown "L3 Tag ways 4~7".
= 0, DISABLE
= 1, ENABLE

> 1, 1, DSU_MEM_SD_ENA1 ; used to shutdown "L3 Tag ways 0~3, L3 Data portion 0, and L3 Victim RAMs".
= 0, DISABLE
= 1, ENABLE

> 0, 1, DSU_MEM_SD_ENA0 ; used to shutdown "Snoop filter and LTDB RAMs".
= 0, DISABLE
= 1, ENABLE

PMU_DSU_STABLE_CNT = 0x80B0 ; DSU power stable count register
> 0, 20, DSU_STABLE_CNT ; VD_DSU power stable count. Number of clk_pmu used by counter logic.

PMU_DSU_PWRUP_CNT = 0x80B4 ; DSU power up count register
> 0, 20, DSU_PWRUP_CNT ; VD_DSU power up count. Number of clk_pmu used by counter logic.

PMU_DSU_PWRDN_CNT = 0x80B8 ; DSU power down count register
> 0, 20, DSU_PWRDN_CNT ; VD_DSU power down count. Number of clk_pmu used by counter logic.

PMU_CORE0_STABLE_CNT = 0x80BC ; BIGCORE0 power stable count register
> 0, 20, CORE0_STABLE_CNT ; VD_BIGCORE0 power stable count. Number of clk_pmu used by counter logic.

PMU_CORE0_PWRUP_CNT = 0x80C0 ; BIGCORE0 power up count register
> 0, 20, CORE0_PWRUP_CNT ; VD_BIGCORE0 power up count. Number of clk_pmu used by counter logic.

PMU_CORE0_PWRDN_CNT = 0x80C4 ; BIGCORE0 power down count register
> 0, 20, CORE0_PWRDN_CNT ; VD_BIGCORE0 power down count. Number of clk_pmu used by counter logic.

PMU_CORE1_STABLE_CNT = 0x80C8 ; BIGCORE1 power stable count register
> 0, 20, CORE1_STABLE_CNT ; VD_BIGCORE1 power stable count. Number of clk_pmu used by counter logic.

PMU_CORE1_PWRUP_CNT = 0x80CC ; BIGCORE1 power up count register
> 0, 20, CORE1_PWRUP_CNT ; VD_BIGCORE1 power up count. Number of clk_pmu used by counter logic.

PMU_CORE1_PWRDN_CNT = 0x80D0 ; BIGCORE1 power down count register
> 0, 20, CORE1_PWRDN_CNT ; VD_BIGCORE1 power down count. Number of clk_pmu used by counter logic.

PMU_CPU0_DBG_RST_CNT = 0x80D4 ; CPU0 debug reset count register
> 0, 20, CPU0_DBG_RST_CNT ; CPU0 debug reset count. Number of clk_pmu used by counter logic. The CPU reset holds low until counter to zero in debug recovery mode.

PMU_CPU1_DBG_RST_CNT = 0x80D8 ; CPU1 debug reset count register
> 0, 20, CPU1_DBG_RST_CNT ; CPU1 debug reset count. Number of clk_pmu used by counter logic. The CPU reset holds low until counter to zero in debug recovery mode.

PMU_CPU2_DBG_RST_CNT = 0x80DC ; CPU2 debug reset count register
> 0, 20, CPU2_DBG_RST_CNT ; CPU2 debug reset count. Number of clk_pmu used by counter logic. The CPU reset holds low until counter to zero in debug recovery mode.

PMU_CPU3_DBG_RST_CNT = 0x80E0 ; CPU3 debug reset count register
> 0, 20, CPU3_DBG_RST_CNT ; CPU3 debug reset count. Number of clk_pmu used by counter logic. The CPU reset holds low until counter to zero in debug recovery mode.

PMU_CPU4_DBG_RST_CNT = 0x80E4 ; CPU4 debug reset count register
> 0, 20, CPU4_DBG_RST_CNT ; CPU4 debug reset count. Number of clk_pmu used by counter logic. The CPU reset holds low until counter to zero in debug recovery mode.

PMU_CPU5_DBG_RST_CNT = 0x80E8 ; CPU5 debug reset count register
> 0, 20, CPU5_DBG_RST_CNT ; CPU5 debug reset count. Number of clk_pmu used by counter logic. The CPU reset holds low until counter to zero in debug recovery mode.

PMU_CPU6_DBG_RST_CNT = 0x80EC ; CPU6 debug reset count register
> 0, 20, CPU6_DBG_RST_CNT ; CPU6 debug reset count. Number of clk_pmu used by counter logic. The CPU reset holds low until counter to zero in debug recovery mode.

PMU_CPU7_DBG_RST_CNT = 0x80F0 ; CPU7 debug reset count register
> 0, 20, CPU7_DBG_RST_CNT ; CPU7 debug reset count. Number of clk_pmu used by counter logic. The CPU reset holds low until counter to zero in debug recovery mode.

PMU_BIU_IDLE_CON0 = 0x8100 ; BIU idle request hardware control register 0
> 15, 1, IDLE_REQ_VO0_ENA ; Enable sending idle request to BIU_VO0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 14, 1, IDLE_REQ_VOP_CHANNEL_ENA ; Enable sending idle request to BIU_VOP_CHANNEL by hardware.
= 0, DISABLE
= 1, ENABLE

> 13, 1, IDLE_REQ_VOP_ENA ; Enable sending idle request to BIU_VOP by hardware.
= 0, DISABLE
= 1, ENABLE

> 12, 1, IDLE_REQ_RGA31_ENA ; Enable sending idle request to BIU_RGA31 by hardware.
= 0, DISABLE
= 1, ENABLE

> 11, 1, IDLE_REQ_ISP1_ENA ; Enable sending idle request to BIU_ISP1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, IDLE_REQ_VI_ENA ; Enable sending idle request to BIU_VI by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, IDLE_REQ_AV1_ENA ; Enable sending idle request to BIU_AV1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 8, 1, IDLE_REQ_VDPU_ENA ; Enable sending idle request to BIU_VDPU by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, IDLE_REQ_RKVDEC1_ENA ; Enable sending idle request to BIU_RKVDEC1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, IDLE_REQ_RKVDEC0_ENA ; Enable sending idle request to BIU_RKVDEC0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, IDLE_REQ_VENC1_ENA ; Enable sending idle request to BIU_VENC1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 4, 1, IDLE_REQ_VENC0_ENA ; Enable sending idle request to BIU_VENC0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, IDLE_REQ_NPU2_ENA ; Enable sending idle request to BIU_NPU2 by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, IDLE_REQ_NPU1_ENA ; Enable sending idle request to BIU_NPU1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, IDLE_REQ_NPUTOP_ENA ; Enable sending idle request to BIU_NPUTOP by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, IDLE_REQ_GPU_ENA ; Enable sending idle request to BIU_GPU by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_BIU_IDLE_CON1 = 0x8104 ; BIU idle request hardware control register 1
> 15, 1, IDLE_REQ_DDRSCH3_ENA ; Enable sending idle request to BIU_DDRSCH3 by hardware.
= 0, DISABLE
= 1, ENABLE

> 14, 1, IDLE_REQ_DDRSCH2_ENA ; Enable sending idle request to BIU_DDRSCH2 by hardware.
= 0, DISABLE
= 1, ENABLE

> 13, 1, IDLE_REQ_DDRSCH1_ENA ; Enable sending idle request to BIU_DDRSCH1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 12, 1, IDLE_REQ_DDRSCH0_ENA ; Enable sending idle request to BIU_DDRSCH0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 11, 1, IDLE_REQ_CENTER_CHANNEL_ENA ; Enable sending idle request to BIU_CENTER_CHANNEL by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, IDLE_REQ_CENTER_ENA ; Enable sending idle request to BIU_CENTER by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, IDLE_REQ_SECURE_VO1USB_CHANNEL_ENA ; Enable sending idle request to BIU_SECURE_VO1USB_CHANNEL by hardware.
= 0, DISABLE
= 1, ENABLE

> 8, 1, IDLE_REQ_SECURE_CENTER_CHANNEL_ENA ; Enable sending idle request to BIU_SECURE_CENTER_CHANNEL by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, IDLE_REQ_SECURE_ENA ; Enable sending idle request to BIU_SECURE by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, IDLE_REQ_VO1USBTOP_ENA ; Enable sending idle request to BIU_VO1USBTOP by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, IDLE_REQ_PHP_ENA ; Enable sending idle request to BIU_PHP by hardware.
= 0, DISABLE
= 1, ENABLE

> 4, 1, IDLE_REQ_USB_ENA ; Enable sending idle request to BIU_USB by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, IDLE_REQ_SDIO_ENA ; Enable sending idle request to BIU_SDIO by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, IDLE_REQ_NVM_ENA ; Enable sending idle request to BIU_NVM by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, IDLE_REQ_AUDIO_ENA ; Enable sending idle request to BIU_AUDIO by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, IDLE_REQ_VO1_ENA ; Enable sending idle request to BIU_VO1 by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_BIU_IDLE_CON2 = 0x8108 ; BIU idle request hardware control register 2
> 2, 1, IDLE_REQ_TOP_ENA ; Enable sending idle request to BIU_TOP by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, IDLE_REQ_BUS_ENA ; Enable sending idle request to BIU_BUS by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, IDLE_REQ_CENTER_DDRSCH_ENA ; Enable sending idle request to BIU_CENTER_DDRSCH by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_BIU_IDLE_SFTCON0 = 0x810C ; BIU idle request software control register 0
> 15, 1, IDLE_REQ_VO0_SFTENA ; Enable sending idle request to BIU_VO0 by software.
= 0, DISABLE
= 1, ENABLE

> 14, 1, IDLE_REQ_VOP_CHANNEL_SFTENA ; Enable sending idle request to BIU_VOP_CHANNEL by software.
= 0, DISABLE
= 1, ENABLE

> 13, 1, IDLE_REQ_VOP_SFTENA ; Enable sending idle request to BIU_VOP by software.
= 0, DISABLE
= 1, ENABLE

> 12, 1, IDLE_REQ_RGA31_SFTENA ; Enable sending idle request to BIU_RGA31 by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, IDLE_REQ_ISP1_SFTENA ; Enable sending idle request to BIU_ISP1 by software.
= 0, DISABLE
= 1, ENABLE

> 10, 1, IDLE_REQ_VI_SFTENA ; Enable sending idle request to BIU_VI by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, IDLE_REQ_AV1_SFTENA ; Enable sending idle request to BIU_AV1 by software.
= 0, DISABLE
= 1, ENABLE

> 8, 1, IDLE_REQ_VDPU_SFTENA ; Enable sending idle request to BIU_VDPU by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, IDLE_REQ_RKVDEC1_SFTENA ; Enable sending idle request to BIU_RKVDEC1 by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, IDLE_REQ_RKVDEC0_SFTENA ; Enable sending idle request to BIU_RKVDEC0 by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, IDLE_REQ_VENC1_SFTENA ; Enable sending idle request to BIU_VENC1 by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, IDLE_REQ_VENC0_SFTENA ; Enable sending idle request to BIU_VENC0 by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, IDLE_REQ_NPU2_SFTENA ; Enable sending idle request to BIU_NPU2 by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, IDLE_REQ_NPU1_SFTENA ; Enable sending idle request to BIU_NPU1 by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, IDLE_REQ_NPUTOP_SFTENA ; Enable sending idle request to BIU_NPUTOP by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, IDLE_REQ_GPU_SFTENA ; Enable sending idle request to BIU_GPU by software.
= 0, DISABLE
= 1, ENABLE

PMU_BIU_IDLE_SFTCON1 = 0x8110 ; BIU idle request software control register 1
> 15, 1, IDLE_REQ_DDRSCH3_SFTENA ; Enable sending idle request to BIU_DDRSCH3 by software.
= 0, DISABLE
= 1, ENABLE

> 14, 1, IDLE_REQ_DDRSCH2_SFTENA ; Enable sending idle request to BIU_DDRSCH2 by software.
= 0, DISABLE
= 1, ENABLE

> 13, 1, IDLE_REQ_DDRSCH1_SFTENA ; Enable sending idle request to BIU_DDRSCH1 by software.
= 0, DISABLE
= 1, ENABLE

> 12, 1, IDLE_REQ_DDRSCH0_SFTENA ; Enable sending idle request to BIU_DDRSCH0 by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, IDLE_REQ_CENTER_CHANNEL_SFTENA ; Enable sending idle request to BIU_CENTER_CHANNEL by software.
= 0, DISABLE
= 1, ENABLE

> 10, 1, IDLE_REQ_CENTER_SFTENA ; Enable sending idle request to BIU_CENTER by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, IDLE_REQ_SECURE_VO1USB_CHANNEL_SFTENA ; Enable sending idle request to BIU_SECURE_VO1USB_CHANNEL by software.
= 0, DISABLE
= 1, ENABLE

> 8, 1, IDLE_REQ_SECURE_CENTER_CHANNEL_SFTENA ; Enable sending idle request to BIU_SECURE_CENTER_CHANNEL by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, IDLE_REQ_SECURE_SFTENA ; Enable sending idle request to BIU_SECURE by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, IDLE_REQ_VO1USBTOP_SFTENA ; Enable sending idle request to BIU_VO1USBTOP by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, IDLE_REQ_PHP_SFTENA ; Enable sending idle request to BIU_PHP by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, IDLE_REQ_USB_SFTENA ; Enable sending idle request to BIU_USB by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, IDLE_REQ_SDIO_SFTENA ; Enable sending idle request to BIU_SDIO by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, IDLE_REQ_NVM_SFTENA ; Enable sending idle request to BIU_NVM by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, IDLE_REQ_AUDIO_SFTENA ; Enable sending idle request to BIU_AUDIO by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, IDLE_REQ_VO1_SFTENA ; Enable sending idle request to BIU_VO1 by software.
= 0, DISABLE
= 1, ENABLE

PMU_BIU_IDLE_SFTCON2 = 0x8114 ; BIU idle request software control register 2
> 2, 1, IDLE_REQ_TOP_SFTENA ; Enable sending idle request to BIU_TOP by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, IDLE_REQ_BUS_SFTENA ; Enable sending idle request to BIU_BUS by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, IDLE_REQ_CENTER_DDRSCH_SFTENA ; Enable sending idle request to BIU_CENTER_DDRSCH by software.
= 0, DISABLE
= 1, ENABLE

PMU_BIU_IDLE_ACK_STS0 = 0x8118 ; BIU idle acknowledge status register 0
> 31, 1, IDLE_ACK_DDRSCH3, RO ; BIU_DDRSCH3 idle acknowledge state.
= 0, NAK
= 1, ACK

> 30, 1, IDLE_ACK_DDRSCH2, RO ; BIU_DDRSCH2 idle acknowledge state.
= 0, NAK
= 1, ACK

> 29, 1, IDLE_ACK_DDRSCH1, RO ; BIU_DDRSCH1 idle acknowledge state.
= 0, NAK
= 1, ACK

> 28, 1, IDLE_ACK_DDRSCH0, RO ; BIU_DDRSCH0 idle acknowledge state.
= 0, NAK
= 1, ACK

> 27, 1, IDLE_ACK_CENTER_CHANNEL, RO ; BIU_CENTER_CHANNEL idle acknowledge state.
= 0, NAK
= 1, ACK

> 26, 1, IDLE_ACK_CENTER, RO ; BIU_CENTER idle acknowledge state.
= 0, NAK
= 1, ACK

> 25, 1, IDLE_ACK_SECURE_VO1USB_CHANNEL, RO ; BIU_SECURE_VO1USB_CHANNEL idle acknowledge state.
= 0, NAK
= 1, ACK

> 24, 1, IDLE_ACK_SECURE_CENTER_CHANNEL, RO ; BIU_SECURE_CENTER_CHANNEL idle acknowledge state.
= 0, NAK
= 1, ACK

> 23, 1, IDLE_ACK_SECURE, RO ; BIU_SECURE idle acknowledge state.
= 0, NAK
= 1, ACK

> 22, 1, IDLE_ACK_VO1USBTOP, RO ; BIU_VO1USBTOP idle acknowledge state.
= 0, NAK
= 1, ACK

> 21, 1, IDLE_ACK_PHP, RO ; BIU_PHP idle acknowledge state.
= 0, NAK
= 1, ACK

> 20, 1, IDLE_ACK_USB, RO ; BIU_USB idle acknowledge state.
= 0, NAK
= 1, ACK

> 19, 1, IDLE_ACK_SDIO, RO ; BIU_SDIO idle acknowledge state.
= 0, NAK
= 1, ACK

> 18, 1, IDLE_ACK_NVM, RO ; BIU_NVM idle acknowledge state.
= 0, NAK
= 1, ACK

> 17, 1, IDLE_ACK_AUDIO, RO ; BIU_AUDIO idle acknowledge state.
= 0, NAK
= 1, ACK

> 16, 1, IDLE_ACK_VO1, RO ; BIU_VO1 idle acknowledge state.
= 0, NAK
= 1, ACK

> 15, 1, IDLE_ACK_VO0, RO ; BIU_VO0 idle acknowledge state.
= 0, NAK
= 1, ACK

> 14, 1, IDLE_ACK_VOP_CHANNEL, RO ; BIU_VOP_CHANNEL idle acknowledge state.
= 0, NAK
= 1, ACK

> 13, 1, IDLE_ACK_VOP, RO ; BIU_VOP idle acknowledge state.
= 0, NAK
= 1, ACK

> 12, 1, IDLE_ACK_RGA31, RO ; BIU_RGA31 idle acknowledge state.
= 0, NAK
= 1, ACK

> 11, 1, IDLE_ACK_ISP1, RO ; BIU_ISP1 idle acknowledge state.
= 0, NAK
= 1, ACK

> 10, 1, IDLE_ACK_VI, RO ; BIU_VI idle acknowledge state.
= 0, NAK
= 1, ACK

> 9, 1, IDLE_ACK_AV1, RO ; BIU_AV1 idle acknowledge state.
= 0, NAK
= 1, ACK

> 8, 1, IDLE_ACK_VDPU, RO ; BIU_VDPU idle acknowledge state.
= 0, NAK
= 1, ACK

> 7, 1, IDLE_ACK_RKVDEC1, RO ; BIU_RKVDEC1 idle acknowledge state.
= 0, NAK
= 1, ACK

> 6, 1, IDLE_ACK_RKVDEC0, RO ; BIU_RKVDEC0 idle acknowledge state.
= 0, NAK
= 1, ACK

> 5, 1, IDLE_ACK_VENC1, RO ; BIU_VENC1 idle acknowledge state.
= 0, NAK
= 1, ACK

> 4, 1, IDLE_ACK_VENC0, RO ; BIU_VENC0 idle acknowledge state.
= 0, NAK
= 1, ACK

> 3, 1, IDLE_ACK_NPU2, RO ; BIU_NPU2 idle acknowledge state.
= 0, NAK
= 1, ACK

> 2, 1, IDLE_ACK_NPU1, RO ; BIU_NPU1 idle acknowledge state.
= 0, NAK
= 1, ACK

> 1, 1, IDLE_ACK_NPUTOP, RO ; BIU_NPUTOP idle acknowledge state.
= 0, NAK
= 1, ACK

> 0, 1, IDLE_ACK_GPU, RO ; BIU_GPU idle acknowledge state.
= 0, NAK
= 1, ACK

PMU_BIU_IDLE_ACK_STS1 = 0x811C ; BIU idle acknowledge status register 1
> 2, 1, IDLE_ACK_TOP, RO ; BIU_TOP idle acknowledge state.
= 0, NAK
= 1, ACK

> 1, 1, IDLE_ACK_BUS, RO ; BIU_BUS idle acknowledge state.
= 0, NAK
= 1, ACK

> 0, 1, IDLE_ACK_CENTER_DDRSCH, RO ; BIU_CENTER_DDRSCH idle acknowledge state.
= 0, NAK
= 1, ACK

PMU_BIU_IDLE_STS0 = 0x8120 ; BIU idle status register 0
> 31, 1, IDLE_DDRSCH3, RO ; BIU_DDRSCH3 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 30, 1, IDLE_DDRSCH2, RO ; BIU_DDRSCH2 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 29, 1, IDLE_DDRSCH1, RO ; BIU_DDRSCH1 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 28, 1, IDLE_DDRSCH0, RO ; BIU_DDRSCH0 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 27, 1, IDLE_CENTER_CHANNEL, RO ; BIU_CENTER_CHANNEL idle state.
= 0, NOT_IDLE
= 1, IDLE

> 26, 1, IDLE_CENTER, RO ; BIU_CENTER idle state.
= 0, NOT_IDLE
= 1, IDLE

> 25, 1, IDLE_SECURE_VO1USB_CHANNEL, RO ; BIU_SECURE_VO1USB_CHANNEL idle state.
= 0, NOT_IDLE
= 1, IDLE

> 24, 1, IDLE_SECURE_CENTER_CHANNEL, RO ; BIU_SECURE_CENTER_CHANNEL idle state.
= 0, NOT_IDLE
= 1, IDLE

> 23, 1, IDLE_SECURE, RO ; BIU_SECURE idle state.
= 0, NOT_IDLE
= 1, IDLE

> 22, 1, IDLE_VO1USBTOP, RO ; BIU_VO1USBTOP idle state.
= 0, NOT_IDLE
= 1, IDLE

> 21, 1, IDLE_PHP, RO ; BIU_PHP idle state.
= 0, NOT_IDLE
= 1, IDLE

> 20, 1, IDLE_USB, RO ; BIU_USB idle state.
= 0, NOT_IDLE
= 1, IDLE

> 19, 1, IDLE_SDIO, RO ; BIU_SDIO idle state.
= 0, NOT_IDLE
= 1, IDLE

> 18, 1, IDLE_NVM, RO ; BIU_NVM idle state.
= 0, NOT_IDLE
= 1, IDLE

> 17, 1, IDLE_AUDIO, RO ; BIU_AUDIO idle state.
= 0, NOT_IDLE
= 1, IDLE

> 16, 1, IDLE_VO1, RO ; BIU_VO1 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 15, 1, IDLE_VO0, RO ; BIU_VO0 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 14, 1, IDLE_VOP_CHANNEL, RO ; BIU_VOP_CHANNEL idle state.
= 0, NOT_IDLE
= 1, IDLE

> 13, 1, IDLE_VOP, RO ; BIU_VOP idle state.
= 0, NOT_IDLE
= 1, IDLE

> 12, 1, IDLE_RGA31, RO ; BIU_RGA31 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 11, 1, IDLE_ISP1, RO ; BIU_ISP1 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 10, 1, IDLE_VI, RO ; BIU_VI idle state.
= 0, NOT_IDLE
= 1, IDLE

> 9, 1, IDLE_AV1, RO ; BIU_AV1 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 8, 1, IDLE_VDPU, RO ; BIU_VDPU idle state.
= 0, NOT_IDLE
= 1, IDLE

> 7, 1, IDLE_RKVDEC1, RO ; BIU_RKVDEC1 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 6, 1, IDLE_RKVDEC0, RO ; BIU_RKVDEC0 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 5, 1, IDLE_VENC1, RO ; BIU_VENC1 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 4, 1, IDLE_VENC0, RO ; BIU_VENC0 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 3, 1, IDLE_NPU2, RO ; BIU_NPU2 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 2, 1, IDLE_NPU1, RO ; BIU_NPU1 idle state.
= 0, NOT_IDLE
= 1, IDLE

> 1, 1, IDLE_NPUTOP, RO ; BIU_NPUTOP idle state.
= 0, NOT_IDLE
= 1, IDLE

> 0, 1, IDLE_GPU, RO ; BIU_GPU idle state.
= 0, NOT_IDLE
= 1, IDLE

PMU_BIU_IDLE_STS1 = 0x8124 ; BIU idle status register 1
> 2, 1, IDLE_TOP, RO ; BIU_TOP idle state.
= 0, NOT_IDLE
= 1, IDLE

> 1, 1, IDLE_BUS, RO ; BIU_BUS idle state.
= 0, NOT_IDLE
= 1, IDLE

> 0, 1, IDLE_CENTER_DDRSCH, RO ; BIU_CENTER_DDRSCH idle state.
= 0, NOT_IDLE
= 1, IDLE

PMU_BIU_AUTO_CON0 = 0x8128 ; BIU automatic power control register 0
> 15, 1, IDLE_AUTO_VO0_ENA ; If enable, BIU_VO0 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 14, 1, IDLE_AUTO_VOP_CHANNEL_ENA ; If enable, BIU_VOP_CHANNEL corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 13, 1, IDLE_AUTO_VOP_ENA ; If enable, BIU_VOP corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 12, 1, IDLE_AUTO_RGA31_ENA ; If enable, BIU_RGA31 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 11, 1, IDLE_AUTO_ISP1_ENA ; If enable, BIU_ISP1 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 10, 1, IDLE_AUTO_VI_ENA ; If enable, BIU_VI corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 9, 1, IDLE_AUTO_AV1_ENA ; If enable, BIU_AV1 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 8, 1, IDLE_AUTO_VDPU_ENA ; If enable, BIU_VDPU corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 7, 1, IDLE_AUTO_RKVDEC1_ENA ; If enable, BIU_RKVDEC1 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 6, 1, IDLE_AUTO_RKVDEC0_ENA ; If enable, BIU_RKVDEC0 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 5, 1, IDLE_AUTO_VENC1_ENA ; If enable, BIU_VENC1 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 4, 1, IDLE_AUTO_VENC0_ENA ; If enable, BIU_VENC0 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 3, 1, IDLE_AUTO_NPU2_ENA ; If enable, BIU_NPU2 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 2, 1, IDLE_AUTO_NPU1_ENA ; If enable, BIU_NPU1 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 1, 1, IDLE_AUTO_NPUTOP_ENA ; If enable, BIU_NPUTOP corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 0, 1, BIU_AUTO_GPU_ENA ; If enable, BIU_GPU corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

PMU_BIU_AUTO_CON1 = 0x812C ; BIU automatic power control register 1
> 15, 1, IDLE_AUTO_DDRSCH3_ENA ; If enable, BIU_DDRSCH3 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 14, 1, IDLE_AUTO_DDRSCH2_ENA ; If enable, BIU_DDRSCH2 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 13, 1, IDLE_AUTO_DDRSCH1_ENA ; If enable, BIU_DDRSCH1 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 12, 1, IDLE_AUTO_DDRSCH0_ENA ; If enable, BIU_DDRSCH0 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 11, 1, IDLE_AUTO_CENTER_CHANNEL_ENA ; If enable, BIU_CENTER_CHANNEL corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 10, 1, IDLE_AUTO_CENTER_ENA ; If enable, BIU_CENTER corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 9, 1, IDLE_AUTO_SECURE_VO1USB_CHANNEL_ENA ; If enable, BIU_SECURE_VO1USB_CHANNEL corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 8, 1, IDLE_AUTO_SECURE_CENTER_CHANNEL_ENA ; If enable, BIU_SECURE_CENTER_CHANNEL corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 7, 1, IDLE_AUTO_SECURE_ENA ; If enable, BIU_SECURE corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 6, 1, IDLE_AUTO_VO1USBTOP_ENA ; If enable, BIU_VO1USBTOP corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 5, 1, IDLE_AUTO_PHP_ENA ; If enable, BIU_PHP corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 4, 1, IDLE_AUTO_USB_ENA ; If enable, BIU_USB corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 3, 1, IDLE_AUTO_SDIO_ENA ; If enable, BIU_SDIO corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 2, 1, IDLE_AUTO_NVM_ENA ; If enable, BIU_NVM corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 1, 1, IDLE_AUTO_AUDIO_ENA ; If enable, BIU_AUDIO corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 0, 1, IDLE_AUTO_VO1_ENA ; If enable, BIU_VO1 corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

PMU_BIU_AUTO_CON2 = 0x8130 ; BIU automatic power control register 2
> 2, 1, IDLE_AUTO_TOP_ENA ; If enable, BIU_TOP corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 1, 1, IDLE_AUTO_BUS_ENA ; If enable, BIU_BUS corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

> 0, 1, IDLE_AUTO_CENTER_DDRSCH_ENA ; If enable, BIU_CENTER_DDRSCH corresponding clock can be opened or gated automatically when idle operation.
= 0, DISABLE
= 1, ENABLE

PMU_PWR_GATE_CON0 = 0x8140 ; Power domain hardware power control register 0
> 15, 1, PD_ISP1_DWN_ENA ; Enable power down PD_ISP1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_FEC_DWN_ENA ; Enable power down PD_FEC by hardware.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_VI_DWN_ENA ; Enable power down PD_VI by hardware.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_AV1_DWN_ENA ; Enable power down PD_AV1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_RGA30_DWN_ENA ; Enable power down PD_RGA30 by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_VDPU_DWN_ENA ; Enable power down PD_VDPU by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_RKVDEC1_DWN_ENA ; Enable power down PD_RKVDEC1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_RKVDEC0_DWN_ENA ; Enable power down PD_RKVDEC0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_VENC1_DWN_ENA ; Enable power down PD_VENC1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_VENC0_DWN_ENA ; Enable power down PD_VENC0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_NPU2_DWN_ENA ; Enable power down PD_NPU2 by hardware.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_NPU1_DWN_ENA ; Enable power down PD_NPU1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_NPUTOP_DWN_ENA ; Enable power down PD_NPUTOP by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_VCODEC_DWN_ENA ; Enable power down VD_VCODEC by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_NPU_DWN_ENA ; Enable power down VD_NPU by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_GPU_DWN_ENA ; Enable power down VD_GPU by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_PWR_GATE_CON1 = 0x8144 ; Power domain hardware power control register 1
> 15, 1, PD_CENTER_DWN_ENA ; Enable power down PD_CENTER by hardware.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_CRYPTO_DWN_ENA ; Enable power down PD_CRYPTO by hardware.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_SDMMC_DWN_ENA ; Enable power down PD_SDMMC by hardware.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_SECURE_DWN_ENA ; Enable power down PD_SECURE by hardware.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_USB_DWN_ENA ; Enable power down PD_USB by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_SDIO_DWN_ENA ; Enable power down PD_SDIO by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_NVM0_DWN_ENA ; Enable power down PD_NVM0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_NVM_DWN_ENA ; Enable power down PD_NVM by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_PCIE_DWN_ENA ; Enable power down PD_PCIE by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_GMAC_DWN_ENA ; Enable power down PD_GMAC by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_PHP_DWN_ENA ; Enable power down PD_PHP by hardware.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_AUDIO_DWN_ENA ; Enable power down PD_AUDIO by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_VO1_DWN_ENA ; Enable power down PD_VO1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_VO0_DWN_ENA ; Enable power down PD_VO0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_VOP_DWN_ENA ; Enable power down PD_VOP by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_RGA31_DWN_ENA ; Enable power down PD_RGA31 by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_PWR_GATE_CON2 = 0x8148 ; Power domain hardware power control register 2
> 1, 1, PD_DDR23_DWN_ENA ; Enable power down VD_DDR23 by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_DDR01_DWN_ENA ; Enable power down VD_DDR01 by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_PWR_GATE_SFTCON0 = 0x814C ; Power domain software power control register 0
> 15, 1, PD_ISP1_DWN_SFTENA ; Enable power down PD_ISP1 by software.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_FEC_DWN_SFTENA ; Enable power down PD_FEC by software.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_VI_DWN_SFTENA ; Enable power down PD_VI by software.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_AV1_DWN_SFTENA ; Enable power down PD_AV1 by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_RGA30_DWN_SFTENA ; Enable power down PD_RGA30 by software.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_VDPU_DWN_SFTENA ; Enable power down PD_VDPU by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_RKVDEC1_DWN_SFTENA ; Enable power down PD_RKVDEC1 by software.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_RKVDEC0_DWN_SFTENA ; Enable power down PD_RKVDEC0 by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_VENC1_DWN_SFTENA ; Enable power down PD_VENC1 by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_VENC0_DWN_SFTENA ; Enable power down PD_VENC0 by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_NPU2_DWN_SFTENA ; Enable power down PD_NPU2 by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_NPU1_DWN_SFTENA ; Enable power down PD_NPU1 by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_NPUTOP_DWN_SFTENA ; Enable power down PD_NPUTOP by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_VCODEC_DWN_SFTENA ; Enable power down VD_VCODEC by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_NPU_DWN_SFTENA ; Enable power down VD_NPU by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_GPU_DWN_SFTENA ; Enable power down VD_GPU by software.
= 0, DISABLE
= 1, ENABLE

PMU_PWR_GATE_SFTCON1 = 0x8150 ; Power domain software power control register 1
> 15, 1, PD_CENTER_DWN_SFTENA ; Enable power down PD_CENTER by software.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_CRYPTO_DWN_SFTENA ; Enable power down PD_CRYPTO by software.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_SDMMC_DWN_SFTENA ; Enable power down PD_SDMMC by software.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_SECURE_DWN_SFTENA ; Enable power down PD_SECURE by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_USB_DWN_SFTENA ; Enable power down PD_USB by software.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_SDIO_DWN_SFTENA ; Enable power down PD_SDIO by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_NVM0_DWN_SFTENA ; Enable power down PD_NVM0 by software.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_NVM_DWN_SFTENA ; Enable power down PD_NVM by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_PCIE_DWN_SFTENA ; Enable power down PD_PCIE by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_GMAC_DWN_SFTENA ; Enable power down PD_GMAC by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_PHP_DWN_SFTENA ; Enable power down PD_PHP by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_AUDIO_DWN_SFTENA ; Enable power down PD_AUDIO by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_VO1_DWN_SFTENA ; Enable power down PD_VO1 by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_VO0_DWN_SFTENA ; Enable power down PD_VO0 by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_VOP_DWN_SFTENA ; Enable power down PD_VOP by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_RGA31_DWN_SFTENA ; Enable power down PD_RGA31 by software.
= 0, DISABLE
= 1, ENABLE

PMU_PWR_GATE_SFTCON2 = 0x8154 ; Power domain software power control register 2
> 1, 1, PD_DDR23_DWN_SFTENA ; Enable power down VD_DDR23 by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_DDR01_DWN_SFTENA ; Enable power down VD_DDR01 by software.
= 0, DISABLE
= 1, ENABLE

PMU_VOL_GATE_CON0 = 0x8158 ; Voltage domain power control register 0
> 2, 1, VD_VCODEC_OFF_ENA ; Enable power off VD_VCODEC.
= 0, DISABLE
= 1, ENABLE

> 1, 1, VD_NPU_OFF_ENA ; Enable power off VD_NPU.
= 0, DISABLE
= 1, ENABLE

> 0, 1, VD_GPU_OFF_ENA ; Enable power off VD_GPU.
= 0, DISABLE
= 1, ENABLE

PMU_VOL_GATE_CON1 = 0x8160 ; Voltage domain power control register 1
> 1, 1, VD_DDR23_OFF_ENA ; Enable power off VD_DDR23.
= 0, DISABLE
= 1, ENABLE

> 0, 1, VD_DDR01_OFF_ENA ; Enable power off VD_DDR01.
= 0, DISABLE
= 1, ENABLE

PMU_PWR_CHAIN_PWRUP_CON0 = 0x8164 ; Power chain stable control register 0 for power up
> 15, 1, PD_ISP1_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_ISP1 power up flow.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_FEC_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_FEC power up flow.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_VI_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_VI power up flow.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_AV1_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_AV1 power up flow.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_RGA30_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_RGA30 power up flow.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_VDPU_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_VDPU power up flow.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_RKVDEC1_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_RKVDEC1 power up flow.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_RKVDEC0_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_RKVDEC0 power up flow.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_VENC1_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_VENC1 power up flow.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_VENC0_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_VENC0 power up flow.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_NPU2_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_NPU2 power up flow.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_NPU1_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_NPU1 power up flow.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_NPUTOP_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_NPUTOP power up flow.
= 0, DISABLE
= 1, ENABLE

PMU_PWR_CHAIN_PWRUP_CON1 = 0x8168 ; Power chain stable control register 1 for power up
> 15, 1, PD_CENTER_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_CENTER power up flow.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_CRYPTO_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_CRYPTO power up flow.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_SDMMC_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_SDMMC power up flow.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_SECURE_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_SECURE power up flow.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_USB_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_USB power up flow.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_SDIO_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_SDIO power up flow.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_NVM0_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_NVM0 power up flow.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_NVM_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_NVM power up flow.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_PCIE_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_PCIE power up flow.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_GMAC_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_GMAC power up flow.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_PHP_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_PHP power up flow.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_AUDIO_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_AUDIO power up flow.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_VO1_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_VO1 power up flow.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_VO0_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_VO0 power up flow.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_VOP_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_VOP power up flow.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_RGA31_PWRUP_STABLE_ENA ; Enable stable counter between power chains for PD_RGA31 power up flow.
= 0, DISABLE
= 1, ENABLE

PMU_PWR_CHAIN_PWRDN_CON0 = 0x8170 ; Power chain stable control register 0 for power down
> 15, 1, PD_ISP1_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_ISP1 power down flow.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_FEC_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_FEC power down flow.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_VI_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_VI power down flow.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_AV1_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_AV1 power down flow.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_RGA30_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_RGA30 power down flow.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_VDPU_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_VDPU power down flow.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_RKVDEC1_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_RKVDEC1 power down flow.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_RKVDEC0_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_RKVDEC0 power down flow.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_VENC1_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_VENC1 power down flow.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_VENC0_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_VENC0 power down flow.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_NPU2_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_NPU2 power down flow.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_NPU1_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_NPU1 power down flow.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_NPUTOP_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_NPUTOP power down flow.
= 0, DISABLE
= 1, ENABLE

PMU_PWR_CHAIN_PWRDN_CON1 = 0x8174 ; Power chain stable control register 1 for power down
> 15, 1, PD_CENTER_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_CENTER power down flow.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_CRYPTO_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_CRYPTO power down flow.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_SDMMC_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_SDMMC power down flow.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_SECURE_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_SECURE power down flow.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_USB_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_USB power down flow.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_SDIO_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_SDIO power down flow.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_NVM0_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_NVM0 power down flow.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_NVM_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_NVM power down flow.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_PCIE_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_PCIE power down flow.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_GMAC_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_GMAC power down flow.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_PHP_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_PHP power down flow.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_AUDIO_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_AUDIO power down flow.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_VO1_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_VO1 power down flow.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_VO0_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_VO0 power down flow.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_VOP_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_VOP power down flow.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_RGA31_PWRDN_STABLE_ENA ; Enable stable counter between power chains for PD_RGA31 power down flow.
= 0, DISABLE
= 1, ENABLE

PMU_PWR_STABLE_CNT = 0x817C ; Power chain stable count register
> 16, 5, PWRDN_STABLE_CNT ; Count for power chain power down stability. Number of clk_pmu used by counter logic.
> 0, 5, PWRUP_STABLE_CNT ; Count for power chain power up stability. Number of clk_pmu used by counter logic.

PMU_PWR_GATE_STS0 = 0x8180 ; Power domain power status register 0
> 31, 1, PD_CENTER_DWN_STAT, RO ; The power state of PD_CENTER.
= 0, POWER_UP
= 1, POWER_DOWN

> 30, 1, PD_CRYPTO_DWN_STAT, RO ; The power state of PD_CRYPTO.
= 0, POWER_UP
= 1, POWER_DOWN

> 29, 1, PD_SDMMC_DWN_STAT, RO ; The power state of PD_SDMMC.
= 0, POWER_UP
= 1, POWER_DOWN

> 28, 1, PD_SECURE_DWN_STAT, RO ; The power state of PD_SECURE.
= 0, POWER_UP
= 1, POWER_DOWN

> 27, 1, PD_USB_DWN_STAT, RO ; The power state of PD_USB.
= 0, POWER_UP
= 1, POWER_DOWN

> 26, 1, PD_SDIO_DWN_STAT, RO ; The power state of PD_SDIO.
= 0, POWER_UP
= 1, POWER_DOWN

> 25, 1, PD_NVM0_DWN_STAT, RO ; The power state of PD_NVM0.
= 0, POWER_UP
= 1, POWER_DOWN

> 24, 1, PD_NVM_DWN_STAT, RO ; The power state of PD_NVM.
= 0, POWER_UP
= 1, POWER_DOWN

> 23, 1, PD_PCIE_DWN_STAT, RO ; The power state of PD_PCIE.
= 0, POWER_UP
= 1, POWER_DOWN

> 22, 1, PD_GMAC_DWN_STAT, RO ; The power state of PD_GMAC.
= 0, POWER_UP
= 1, POWER_DOWN

> 21, 1, PD_PHP_DWN_STAT, RO ; The power state of PD_PHP.
= 0, POWER_UP
= 1, POWER_DOWN

> 20, 1, PD_AUDIO_DWN_STAT, RO ; The power state of PD_AUDIO.
= 0, POWER_UP
= 1, POWER_DOWN

> 19, 1, PD_VO1_DWN_STAT, RO ; The power state of PD_VO1.
= 0, POWER_UP
= 1, POWER_DOWN

> 18, 1, PD_VO0_DWN_STAT, RO ; The power state of PD_VO0.
= 0, POWER_UP
= 1, POWER_DOWN

> 17, 1, PD_VOP_DWN_STAT, RO ; The power state of PD_VOP.
= 0, POWER_UP
= 1, POWER_DOWN

> 16, 1, PD_RGA31_DWN_STAT, RO ; The power state of PD_RGA31.
= 0, POWER_UP
= 1, POWER_DOWN

> 15, 1, PD_ISP1_DWN_STAT, RO ; The power state of PD_ISP1.
= 0, POWER_UP
= 1, POWER_DOWN

> 14, 1, PD_FEC_DWN_STAT, RO ; The power state of PD_FEC.
= 0, POWER_UP
= 1, POWER_DOWN

> 13, 1, PD_VI_DWN_STAT, RO ; The power state of PD_VI.
= 0, POWER_UP
= 1, POWER_DOWN

> 12, 1, PD_AV1_DWN_STAT, RO ; The power state of PD_AV1.
= 0, POWER_UP
= 1, POWER_DOWN

> 11, 1, PD_RGA30_DWN_STAT, RO ; The power state of PD_RGA30.
= 0, POWER_UP
= 1, POWER_DOWN

> 10, 1, PD_VDPU_DWN_STAT, RO ; The power state of PD_VDPU.
= 0, POWER_UP
= 1, POWER_DOWN

> 9, 1, PD_RKVDEC1_DWN_STAT, RO ; The power state of PD_RKVDEC1.
= 0, POWER_UP
= 1, POWER_DOWN

> 8, 1, PD_RKVDEC0_DWN_STAT, RO ; The power state of PD_RKVDEC0.
= 0, POWER_UP
= 1, POWER_DOWN

> 7, 1, PD_VENC1_DWN_STAT, RO ; The power state of PD_VENC1.
= 0, POWER_UP
= 1, POWER_DOWN

> 6, 1, PD_VENC0_DWN_STAT, RO ; The power state of PD_VENC0.
= 0, POWER_UP
= 1, POWER_DOWN

> 5, 1, PD_NPU2_DWN_STAT, RO ; The power state of PD_NPU2.
= 0, POWER_UP
= 1, POWER_DOWN

> 4, 1, PD_NPU1_DWN_STAT, RO ; The power state of PD_NPU1.
= 0, POWER_UP
= 1, POWER_DOWN

> 3, 1, PD_NPUTOP_DWN_STAT, RO ; The power state of PD_NPUTOP.
= 0, POWER_UP
= 1, POWER_DOWN

> 2, 1, PD_VCODEC_DWN_STAT, RO ; The power state of VD_VCODEC.
= 0, POWER_UP
= 1, POWER_DOWN

> 1, 1, PD_NPU_DWN_STAT, RO ; The power state of VD_NPU.
= 0, POWER_UP
= 1, POWER_DOWN

> 0, 1, PD_GPU_DWN_STAT, RO ; The power state of VD_GPU.
= 0, POWER_UP
= 1, POWER_DOWN

PMU_PWR_GATE_STS1 = 0x8184 ; Power domain power status register 1
> 1, 1, PD_DDR23_DWN_STAT, RO ; The power state of VD_DDR23.
= 0, POWER_UP
= 1, POWER_DOWN

> 0, 1, PD_DDR01_DWN_STAT, RO ; The power state of VD_DDR01.
= 0, POWER_UP
= 1, POWER_DOWN

PMU_PWR_GATE_POWER_STS = 0x8188 ; Power gating status register
> 0, 3, POWER_GATE_STATE, RO ; Power gating state.
= 0, _ ; Normal state
= 1, _ ; Power down start state
= 2, _ ; Power down running state
= 3, _ ; Wait for power up state
= 4, _ ; Power up start state
= 5, _ ; Power up running state

PMU_VOL_GATE_FAST_CON = 0x818C ; Voltage domain fast power control register
> 1, 1, VD_NPU_FAST_ENA ; Enable VD_NPU fast power control. When asserted, it means that VD_NPU will power up completely if VD_NPU power up count from npu_pwrup_cnt (defined in PMU_NPU_PWRUP_CNT) to zero when VD_NPU power up request active, or VD_NPU will power down completely if VD_NPU power down count from npu_pwrdn_cnt (defined in PMU_NPU_PWRDN_CNT) to zero when VD_NPU power down request active. Otherwise, it means that VD_NPU will power up completely as soon as VD_NPU power up request active, or power down completely as soon as VD_NPU power down request active.
= 0, DISABLE
= 1, ENABLE

> 0, 1, VD_GPU_FAST_ENA ; Enable VD_GPU fast power control. When asserted, it means that VD_GPU will power up completely if VD_GPU power up count from gpu_pwrup_cnt (defined in PMU_GPU_PWRUP_CNT) to zero when VD_GPU power up request active, or VD_GPU will power down completely if VD_GPU power down count from gpu_pwrdn_cnt (defined in PMU_GPU_PWRDN_CNT) to zero when VD_GPU power down request active. Otherwise, it means that VD_GPU will power up completely as soon as VD_GPU power up request active, or power down completely as soon as VD_GPU power down request active.
= 0, DISABLE
= 1, ENABLE

PMU_GPU_PWRUP_CNT = 0x8190 ; VD_GPU power up count register
> 0, 20, GPU_PWRUP_CNT ; VD_GPU power up count. Number of clk_pmu used by counter logic.

PMU_GPU_PWRDN_CNT = 0x8194 ; VD_GPU power down count register
> 0, 20, GPU_PWRDN_CNT ; VD_GPU power down count. Number of clk_pmu used by counter logic.

PMU_NPU_PWRUP_CNT = 0x8198 ; VD_NPU power up count register
> 0, 20, NPU_PWRUP_CNT ; VD_NPU power up count. Number of clk_pmu used by counter logic.

PMU_NPU_PWRDN_CNT = 0x819C ; VD_NPU power down count register
> 0, 20, NPU_PWRDN_CNT ; VD_NPU power down count. Number of clk_pmu used by counter logic.

PMU_MEM_PWR_GATE_SFTCON0 = 0x81A0 ; Memory software power control register 0
> 15, 1, PD_ISP1_MEM_DWN_SFTENA ; Enable power down PD_ISP1's memory by software.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_FEC_MEM_DWN_SFTENA ; Enable power down PD_FEC's memory by software.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_VI_MEM_DWN_SFTENA ; Enable power down PD_VI's memory by software.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_AV1_MEM_DWN_SFTENA ; Enable power down PD_AV1's memory by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_RGA30_MEM_DWN_SFTENA ; Enable power down PD_RGA30's memory by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_RKVDEC1_MEM_DWN_SFTENA ; Enable power down PD_RKVDEC1's memory by software.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_RKVDEC0_MEM_DWN_SFTENA ; Enable power down PD_RKVDEC0's memory by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_VENC1_MEM_DWN_SFTENA ; Enable power down PD_VENC1's memory by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_VENC0_MEM_DWN_SFTENA ; Enable power down PD_VENC0's memory by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_NPU2_MEM_DWN_SFTENA ; Enable power down PD_NPU2's memory by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_NPU1_MEM_DWN_SFTENA ; Enable power down PD_NPU1's memory by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_NPUTOP_MEM_DWN_SFTENA ; Enable power down PD_NPUTOP's memory by software.
= 0, DISABLE
= 1, ENABLE

PMU_MEM_PWR_GATE_SFTCON1 = 0x81A4 ; Memory software power control register 1
> 15, 1, PD_CENTER_MEM_DWN_SFTENA ; Enable power down PD_CENTER's memory by software.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_CRYPTO_MEM_DWN_SFTENA ; Enable power down PD_CRYPTO's memory by software.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_SDMMC_MEM_DWN_SFTENA ; Enable power down PD_SDMMC's memory by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_USB_MEM_DWN_SFTENA ; Enable power down PD_USB's memory by software.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_SDIO_MEM_DWN_SFTENA ; Enable power down PD_SDIO's memory by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_NVM0_MEM_DWN_SFTENA ; Enable power down PD_NVM0's memory by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_PCIE_MEM_DWN_SFTENA ; Enable power down PD_PCIE's memory by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_GMAC_MEM_DWN_SFTENA ; Enable power down PD_GMAC's memory by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_PHP_MEM_DWN_SFTENA ; Enable power down PD_PHP's memory by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_AUDIO_MEM_DWN_SFTENA ; Enable power down PD_AUDIO's memory by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_VO1_MEM_DWN_SFTENA ; Enable power down PD_VO1's memory by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_VO0_MEM_DWN_SFTENA ; Enable power down PD_VO0's memory by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_VOP_MEM_DWN_SFTENA ; Enable power down PD_VOP's memory by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_RGA31_MEM_DWN_SFTENA ; Enable power down PD_RGA31's memory by software.
= 0, DISABLE
= 1, ENABLE

PMU_MEM_PWR_GATE_SFTCON2 = 0x81A8 ; Memory software power control register 2
> 1, 1, PD_DDR23_MEM_DWN_SFTENA ; Enable power down VD_DDR23's memory by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_DDR01_MEM_DWN_SFTENA ; Enable power down VD_DDR01's memory by software.
= 0, DISABLE
= 1, ENABLE

PMU_SUBMEM_PWR_GATE_SFTCON0 = 0x81B0 ; Submodule memory software power control register 0
> 15, 1, SHRM_BLK3_DS_CTRL ; Control share memory block 3 deep sleep mode by software.
= 0, INVALID
= 1, VALID

> 14, 1, SHRM_BLK2_DS_CTRL ; Control share memory block 2 deep sleep mode by software.
= 0, INVALID
= 1, VALID

> 13, 1, SHRM_BLK1_DS_CTRL ; Control share memory block 1 deep sleep mode by software.
= 0, INVALID
= 1, VALID

> 12, 1, SHRM_BLK0_DS_CTRL ; Control share memory block 0 deep sleep mode by software.
= 0, INVALID
= 1, VALID

> 11, 1, SHRM_BLK3_SD_CTRL ; Control share memory block 3 shutdown mode by software.
= 0, INVALID
= 1, VALID

> 10, 1, SHRM_BLK2_SD_CTRL ; Control share memory block 2 shutdown mode by software.
= 0, INVALID
= 1, VALID

> 9, 1, SHRM_BLK1_SD_CTRL ; Control share memory block 1 shutdown mode by software.
= 0, INVALID
= 1, VALID

> 8, 1, SHRM_BLK0_SD_CTRL ; Control share memory block 0 shutdown mode by software.
= 0, INVALID
= 1, VALID

> 7, 1, SHRM_BLK3_DS_ENA ; Enable share memory block 3 deep sleep mode by software. It should be set to 1 before shrm_blk3_ds_ctrl set to 1, and set to 0 after shrm_blk3_ds_ctrl set to 0.
= 0, DISABLE
= 1, ENABLE

> 6, 1, SHRM_BLK2_DS_ENA ; Enable share memory block 2 deep sleep mode by software. It should be set to 1 before shrm_blk2_ds_ctrl set to 1, and set to 0 after shrm_blk2_ds_ctrl set to 0.
= 0, DISABLE
= 1, ENABLE

> 5, 1, SHRM_BLK1_DS_ENA ; Enable share memory block 1 deep sleep mode by software. It should be set to 1 before shrm_blk1_ds_ctrl set to 1, and set to 0 after shrm_blk1_ds_ctrl set to 0.
= 0, DISABLE
= 1, ENABLE

> 4, 1, SHRM_BLK0_DS_ENA ; Enable share memory block 0 deep sleep mode by software. It should be set to 1 before shrm_blk0_ds_ctrl set to 1, and set to 0 after shrm_blk0_ds_ctrl set to 0.
= 0, DISABLE
= 1, ENABLE

> 3, 1, SHRM_BLK3_SD_ENA ; Enable share memory block 3 shutdown mode by software. It should be set to 1 before shrm_blk3_sd_ctrl set to 1, and set to 0 after shrm_blk3_sd_ctrl set to 0.
= 0, DISABLE
= 1, ENABLE

> 2, 1, SHRM_BLK2_SD_ENA ; Enable share memory block 2 shutdown mode by software. It should be set to 1 before shrm_blk2_sd_ctrl set to 1, and set to 0 after shrm_blk2_sd_ctrl set to 0.
= 0, DISABLE
= 1, ENABLE

> 1, 1, SHRM_BLK1_SD_ENA ; Enable share memory block 1 shutdown mode by software. It should be set to 1 before shrm_blk1_sd_ctrl set to 1, and set to 0 after shrm_blk1_sd_ctrl set to 0.
= 0, DISABLE
= 1, ENABLE

> 0, 1, SHRM_BLK0_SD_ENA ; Enable share memory block 0 shutdown mode by software. It should be set to 1 before shrm_blk0_sd_ctrl set to 1, and set to 0 after shrm_blk0_sd_ctrl set to 0.
= 0, DISABLE
= 1, ENABLE

PMU_SUBMEM_PWR_GATE_SFTCON1 = 0x81B4 ; Submodule memory software power control register 1
> 15, 1, VOPPOST0_MEM_DWN_SFTENA ; Enable shutdown VOPPOST0 memory by software.
= 0, DISABLE
= 1, ENABLE

> 14, 1, JPEGENC3_MEM_DWN_SFTENA ; Enable shutdown JPEGENC3 memory by software.
= 0, DISABLE
= 1, ENABLE

> 13, 1, JPEGENC2_MEM_DWN_SFTENA ; Enable shutdown JPEGENC2 memory by software.
= 0, DISABLE
= 1, ENABLE

> 12, 1, JPEGENC1_MEM_DWN_SFTENA ; Enable shutdown JPEGENC1 memory by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, JPEGENC0_MEM_DWN_SFTENA ; Enable shutdown JPEGENC0 memory by software.
= 0, DISABLE
= 1, ENABLE

> 10, 1, JPEGDEC_MEM_DWN_SFTENA ; Enable shutdown JPEGDEC memory by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, IEP_MEM_DWN_SFTENA ; Enable shutdown IEP memory by software.
= 0, DISABLE
= 1, ENABLE

> 8, 1, RGA2_MEM_DWN_SFTENA ; Enable shutdown RGA2 memory by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, VDPU_MEM_DWN_SFTENA ; Enable shutdown VDPU memory by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, USB3_MEM_DWN_SFTENA ; Enable shutdown USB3OTG_2 memory by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, SATA_MEM_DWN_SFTENA ; Enable shutdown SATA_0/1/2 memory by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PHPMMU_MEM_DWN_SFTENA ; Enable shutdown PHPMMU memory by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PCIEMMU_MEM_DWN_SFTENA ; Enable shutdown PCIEMMU memory by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PCIE1L2_MEM_DWN_SFTENA ; Enable shutdown PCIE3_1L2 memory by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PCIE1L1_MEM_DWN_SFTENA ; Enable shutdown PCIE3_1L1 memory by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PCIE1L0_MEM_DWN_SFTENA ; Enable shutdown PCIE3_1L0 memory by software.
= 0, DISABLE
= 1, ENABLE

PMU_SUBMEM_PWR_GATE_SFTCON2 = 0x81B8 ; Submodule memory software power control register 2
> 8, 1, DSIHOST1_MEM_DWN_SFTENA ; Enable shutdown DSIHOST1 memory by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, DSIHOST0_MEM_DWN_SFTENA ; Enable shutdown DSIHOST0 memory by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, VOPWB_MEM_DWN_SFTENA ; Enable shutdown VOPWB memory by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, VOPDOLBY3_MEM_DWN_SFTENA ; Enable shutdown VOPDOLBY3 memory by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, VOPDOLBY2_MEM_DWN_SFTENA ; Enable shutdown VOPDOLBY2 memory by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, VOPDOLBY1_MEM_DWN_SFTENA ; Enable shutdown VOPDOLBY1 memory by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, VOPPOST3_MEM_DWN_SFTENA ; Enable shutdown VOPPOST3 memory by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, VOPPOST2_MEM_DWN_SFTENA ; Enable shutdown VOPPOST2 memory by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, VOPPOST1_MEM_DWN_SFTENA ; Enable shutdown VOPPOST1 memory by software.
= 0, DISABLE
= 1, ENABLE

PMU_SUBMEM_PWR_GATE_STS = 0x81BC ; Submodule memory power status register
> 28, 1, DSIHOST1_MEM_DWN_STAT, RO ; DSIHOST1 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 27, 1, DSIHOST0_MEM_DWN_STAT, RO ; DSIHOST0 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 26, 1, VOPWB_MEM_DWN_STAT, RO ; VOPWB memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 25, 1, VOPDOLBY3_MEM_DWN_STAT, RO ; VOPDOLBY3 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 24, 1, VOPDOLBY2_MEM_DWN_STAT, RO ; VOPDOLBY2 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 23, 1, VOPDOLBY1_MEM_DWN_STAT, RO ; VOPDOLBY1 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 22, 1, VOPPOST3_MEM_DWN_STAT, RO ; VOPPOST3 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 21, 1, VOPPOST2_MEM_DWN_STAT, RO ; VOPPOST2 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 20, 1, VOPPOST1_MEM_DWN_STAT, RO ; VOPPOST1 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 19, 1, VOPPOST0_MEM_DWN_STAT, RO ; VOPPOST0 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 18, 1, JPEGENC3_MEM_DWN_STAT, RO ; JPEGENC3 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 17, 1, JPEGENC2_MEM_DWN_STAT, RO ; JPEGENC2 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 16, 1, JPEGENC1_MEM_DWN_STAT, RO ; JPEGENC1 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 15, 1, JPEGENC0_MEM_DWN_STAT, RO ; JPEGENC0 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 14, 1, JPEGDEC_MEM_DWN_STAT, RO ; JPEGDEC memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 13, 1, IEP_MEM_DWN_STAT, RO ; IEP memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 12, 1, RGA2_MEM_DWN_STAT, RO ; RGA2 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 11, 1, VDPU_MEM_DWN_STAT, RO ; VDPU memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 10, 1, USB3_MEM_DWN_STAT, RO ; USB3OTG_2 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 9, 1, SATA_MEM_DWN_STAT, RO ; SATA_0/1/2 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 8, 1, PHPMMU_MEM_DWN_STAT, RO ; PHPMMU memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 7, 1, PCIEMMU_MEM_DWN_STAT, RO ; PCIEMMU memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 6, 1, PCIE1L2_MEM_DWN_STAT, RO ; PCIE3_1L2 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 5, 1, PCIE1L1_MEM_DWN_STAT, RO ; PCIE3_1L1 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 4, 1, PCIE1L0_MEM_PWR_STAT, RO ; PCIE3_1L0 memory power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 3, 1, SHRM_BLK3_PWR_STAT, RO ; Share memory block 3 power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 2, 1, SHRM_BLK2_PWR_STAT, RO ; Share memory block 2 power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 1, 1, SHRM_BLK1_PWR_STAT, RO ; Share memory block 1 power status.
= 0, POWER_UP
= 1, POWER_DOWN

> 0, 1, SHRM_BLK0_PWR_STAT, RO ; Share memory block 0 power status.
= 0, POWER_UP
= 1, POWER_DOWN

PMU_SUBMEM_PWR_ACK_BYPASS_CON0 = 0x81C0 ; Submodule memory power acknowledge bypass control register 0
> 15, 1, VOPPOST0_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass VOPPOST0 memory power up or power down acknowledge. If asserted, it does not need to wait for VOPPOST0 memory power up or power down acknowledge for PD_VOP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 14, 1, JPEGENC3_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass JPEGENC3 memory power up or power down acknowledge. If asserted, it does not need to wait for JPEGENC3 memory power up or power down acknowledge for PD_VDPU power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 13, 1, JPEGENC2_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass JPEGENC2 memory power up or power down acknowledge. If asserted, it does not need to wait for JPEGENC2 memory power up or power down acknowledge for PD_VDPU power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 12, 1, JPEGENC1_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass JPEGENC1 memory power up or power down acknowledge. If asserted, it does not need to wait for JPEGENC1 memory power up or power down acknowledge for PD_VDPU power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 11, 1, JPEGENC0_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass JPEGENC0 memory power up or power down acknowledge. If asserted, it does not need to wait for JPEGENC0 memory power up or power down acknowledge for PD_VDPU power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 10, 1, JPEGDEC_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass JPEGDEC memory power up or power down acknowledge. If asserted, it does not need to wait for JPEGDEC memory power up or power down acknowledge for PD_VDPU power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 9, 1, IEP_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass IEP memory power up or power down acknowledge. If asserted, it does not need to wait for IEP memory power up or power down acknowledge for PD_VDPU power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 8, 1, RGA2_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass RGA2 memory power up or power down acknowledge. If asserted, it does not need to wait for RGA2 memory power up or power down acknowledge for PD_VDPU power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 7, 1, VDPU_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass VDPU memory power up or power down acknowledge. If asserted, it does not need to wait for VDPU memory power up or power down acknowledge for PD_VDPU power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 6, 1, USB3_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass USB3OTG_2 memory power up or power down acknowledge. If asserted, it does not need to wait for USB3OTG_2 memory power up or power down acknowledge for PD_PHP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 5, 1, SATA_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass SATA_0/1/2 memory power up or power down acknowledge. If asserted, it does not need to wait for SATA_0/1/2 memory power up or power down acknowledge for PD_PHP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PHPMMU_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass PHPMMU memory power up or power down acknowledge. If asserted, it does not need to wait for PHPMMU memory power up or power down acknowledge for PD_PHP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PCIEMMU_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass PCIEMMU memory power up or power down acknowledge. If asserted, it does not need to wait for PCIEMMU memory power up or power down acknowledge for PD_PHP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PCIE1L2_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass PCIE3_1L2 memory power up or power down acknowledge. If asserted, it does not need to wait for PCIE3_1L2 memory power up or power down acknowledge for PD_PHP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PCIE1L1_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass PCIE3_1L1 memory power up or power down acknowledge. If asserted, it does not need to wait for PCIE3_1L1 memory power up or power down acknowledge for PD_PHP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PCIE1L0_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass PCIE3_1L0 memory power up or power down acknowledge. If asserted, it does not need to wait for PCIE3_1L0 memory power up or power down acknowledge for PD_PHP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

PMU_SUBMEM_PWR_ACK_BYPASS_CON1 = 0x81C4 ; Submodule memory power acknowledge bypass control register 1
> 12, 1, SHRM_BLK3_DWN_ACK_BYPASS_ENA ; Enable bypass share memory block3 memory power up or power down acknowledge. If asserted, it does not need to wait for share memory block3 memory power up or power down acknowledge for PD_CENTER power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 11, 1, SHRM_BLK2_DWN_ACK_BYPASS_ENA ; Enable bypass share memory block2 memory power up or power down acknowledge. If asserted, it does not need to wait for share memory block2 memory power up or power down acknowledge for PD_CENTER power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 10, 1, SHRM_BLK1_DWN_ACK_BYPASS_ENA ; Enable bypass share memory block1 memory power up or power down acknowledge. If asserted, it does not need to wait for share memory block1 memory power up or power down acknowledge for PD_CENTER power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 9, 1, SHRM_BLK0_DWN_ACK_BYPASS_ENA ; Enable bypass share memory block0 memory power up or power down acknowledge. If asserted, it does not need to wait for share memory block0 memory power up or power down acknowledge for PD_CENTER power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 8, 1, DSIHOST1_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass DSIHOST1 memory power up or power down acknowledge. If asserted, it does not need to wait for DSIHOST1 memory power up or power down acknowledge for PD_VOP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 7, 1, DSIHOST0_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass DSIHOST0 memory power up or power down acknowledge. If asserted, it does not need to wait for DSIHOST0 memory power up or power down acknowledge for PD_VOP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 6, 1, VOPWB_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass VOPWB memory power up or power down acknowledge. If asserted, it does not need to wait for VOPWB memory power up or power down acknowledge for PD_VOP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 5, 1, VOPDOLBY3_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass VOPDOLBY3 memory power up or power down acknowledge. If asserted, it does not need to wait for VOPDOLBY3 memory power up or power down acknowledge for PD_VOP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 4, 1, VOPDOLBY2_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass VOPDOLBY2 memory power up or power down acknowledge. If asserted, it does not need to wait for VOPDOLBY2 memory power up or power down acknowledge for PD_VOP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 3, 1, VOPDOLBY1_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass VOPDOLBY1 memory power up or power down acknowledge. If asserted, it does not need to wait for VOPDOLBY1 memory power up or power down acknowledge for PD_VOP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 2, 1, VOPPOST3_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass VOPPOST3 memory power up or power down acknowledge. If asserted, it does not need to wait for VOPPOST3 memory power up or power down acknowledge for PD_VOP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 1, 1, VOPPOST2_MEM_PWR_ACK_BYPASS_ENA ; Enable bypass VOPPOST2 memory power up or power down acknowledge. If asserted, it does not need to wait for VOPPOST2 memory power up or power down acknowledge for PD_VOP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

> 0, 1, VOPPOST1_DWN_ACK_BYPASS_ENA ; Enable bypass VOPPOST1 memory power up or power down acknowledge. If asserted, it does not need to wait for VOPPOST1 memory power up or power down acknowledge for PD_VOP power up or power down flow.
= 0, DISABLE
= 1, ENABLE

PMU_QCHANNEL_PWR_CON = 0x81D0 ; Q-Channel hardware power control register
> 6, 1, BUSGIC_ITS1_QCH_ENA ; Enable BUSGIC-ITS1 Q-Channel power control by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, BUSGIC_ITS0_QCH_ENA ; Enable BUSGIC-ITS0 Q-Channel power control by hardware.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PHPGIC_ITS_QCH_ENA ; Enable PHPGIC-ITS Q-Channel power control by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PCIEMMU_TCU_QCH_ENA ; Enable PCIEMMU-TCU Q-Channel power control by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PCIEMMU_TBU_QCH_ENA ; Enable PCIEMMU-TBU Q-Channel power control by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PHPMMU_TCU_QCH_ENA ; Enable PHPMMU-TCU Q-Channel power control by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PHPMMU_TBU_QCH_ENA ; Enable PHPMMU-TBU Q-Channel power control by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_QCHANNEL_PWR_SFTCON = 0x81D4 ; Q-Channel software power control register
> 6, 1, BUSGIC_ITS1_QCH_SFTENA ; Enable BUSGIC-ITS1 Q-Channel power control by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, BUSGIC_ITS0_QCH_SFTENA ; Enable BUSGIC-ITS0 Q-Channel power control by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PHPGIC_ITS_QCH_SFTENA ; Enable PHPGIC-ITS Q-Channel power control by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PCIEMMU_TCU_QCH_SFTENA ; Enable PCIEMMU-TCU Q-Channel power control by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PCIEMMU_TBU_QCH_SFTENA ; Enable PCIEMMU-TBU Q-Channel power control by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PHPMMU_TCU_QCH_SFTENA ; Enable PHPMMU-TCU Q-Channel power control by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PHPMMU_TBU_QCH_SFTENA ; Enable PHPMMU-TBU Q-Channel power control by software.
= 0, DISABLE
= 1, ENABLE

PMU_QCHANNEL_PWR_STS = 0x81D8 ; Q-Channel power status register
> 27, 1, BUSGIC_ITS1_QCH_REQ, RO ; Request status for BUSGIC-ITS1 Q-Channel power control.
= 0, NOT_VALID
= 1, VALID

> 26, 1, BUSGIC_ITS0_QCH_REQ, RO ; Request status for BUSGIC-ITS0 Q-Channel power control.
= 0, NOT_VALID
= 1, VALID

> 25, 1, PHPGIC_ITS_QCH_REQ, RO ; Request status for PHPGIC-ITS Q-Channel power control.
= 0, NOT_VALID
= 1, VALID

> 24, 1, PCIEMMU_TCU_QCH_REQ, RO ; Request status for PCIEMMU-TCU Q-Channel power control.
= 0, NOT_VALID
= 1, VALID

> 23, 1, PCIEMMU_TBU_QCH_REQ, RO ; Request status for PCIEMMU-TBU Q-Channel power control.
= 0, NOT_VALID
= 1, VALID

> 22, 1, PHPMMU_TCU_QCH_REQ, RO ; Request status for PHPMMU-TCU Q-Channel power control.
= 0, NOT_VALID
= 1, VALID

> 21, 1, PHPMMU_TBU_QCH_REQ, RO ; Request status for PHPMMU-TBU Q-Channel power control.
= 0, NOT_VALID
= 1, VALID

> 20, 1, BUSGIC_ITS1_QCH_ACTIVE, RO ; Active status for PHPBUS-ITS1 Q-Channel power control.
= 0, INACTIVE
= 1, ACTIVE

> 19, 1, BUSGIC_ITS0_QCH_ACTIVE, RO ; Active status for PHPBUS-ITS0 Q-Channel power control.
= 0, INACTIVE
= 1, ACTIVE

> 18, 1, PHPGIC_ITS_QCH_ACTIVE, RO ; Active status for PHPGIC-ITS Q-Channel power control.
= 0, INACTIVE
= 1, ACTIVE

> 17, 1, PCIEMMU_TCU_QCH_ACTIVE, RO ; Active status for PCIEMMU-TCU Q-Channel power control.
= 0, INACTIVE
= 1, ACTIVE

> 16, 1, PCIEMMU_TBU_QCH_ACTIVE, RO ; Active status for PCIEMMU-TBU Q-Channel power control.
= 0, INACTIVE
= 1, ACTIVE

> 15, 1, PHPMMU_TCU_QCH_ACTIVE, RO ; Active status for PHPMMU-TCU Q-Channel power control.
= 0, INACTIVE
= 1, ACTIVE

> 14, 1, PHPMMU_TBU_QCH_ACTIVE, RO ; Active status for PHPMMU-TBU Q-Channel power control.
= 0, INACTIVE
= 1, ACTIVE

> 13, 1, BUSGIC_ITS1_QCH_DENY, RO ; Deny status for PBUSGIC-ITS1 Q-Channel power control.
= 0, NOT_DENY
= 1, DENY

> 12, 1, BUSGIC_ITS0_QCH_DENY, RO ; Deny status for BUSGIC-ITS0 Q-Channel power control.
= 0, NOT_DENY
= 1, DENY

> 11, 1, PHPGIC_ITS_QCH_DENY, RO ; Deny status for PHPGIC-ITS Q-Channel power control.
= 0, NOT_DENY
= 1, DENY

> 10, 1, PCIEMMU_TCU_QCH_DENY, RO ; Deny status for PCIEMMU-TCU Q-Channel power control.
= 0, NOT_DENY
= 1, DENY

> 9, 1, PCIEMMU_TBU_QCH_DENY, RO ; Deny status for PCIEMMU-TBU Q-Channel power control.
= 0, NOT_DENY
= 1, DENY

> 8, 1, PHPMMU_TCU_QCH_DENY, RO ; Deny status for PHPMMU-TCU Q-Channel power control.
= 0, NOT_DENY
= 1, DENY

> 7, 1, PHPMMU_TBU_QCH_DENY, RO ; Deny status for PHPMMU-TBU Q-Channel power control.
= 0, NOT_DENY
= 1, DENY

> 6, 1, BUSGIC_ITS1_QCH_ACCEPT, RO ; Accept status for BUSGIC-ITS1 Q-Channel power control.
= 0, NOT_ACCEPT
= 1, ACCEPT

> 5, 1, BUSGIC_ITS0_QCH_ACCEPT, RO ; Accept status for BUSGIC-ITS0 Q-Channel power control.
= 0, NOT_ACCEPT
= 1, ACCEPT

> 4, 1, PHPGIC_ITS_QCH_ACCEPT, RO ; Accept status for PHPGIC-ITS Q-Channel power control.
= 0, NOT_ACCEPT
= 1, ACCEPT

> 3, 1, PCIEMMU_TCU_QCH_ACCEPT, RO ; Accept status for PCIEMMU-TCU Q-Channel power control.
= 0, NOT_ACCEPT
= 1, ACCEPT

> 2, 1, PCIEMMU_TBU_QCH_ACCEPT, RO ; Accept status for PCIEMMU-TBU Q-Channel power control.
= 0, NOT_ACCEPT
= 1, ACCEPT

> 1, 1, PHPMMU_TCU_QCH_ACCEPT, RO ; Accept status for PHPMMU-TCU Q-Channel power control.
= 0, NOT_ACCEPT
= 1, ACCEPT

> 0, 1, PHPMMU_TBU_QCH_ACCEPT, RO ; Accept status for PHPMMU-TBU Q-Channel power control.
= 0, NOT_ACCEPT
= 1, ACCEPT

PMU_DEBUG_INFO_CON = 0x81E0 ; PMU debug information control register
> 10, 1, CPU_POWER_STATE_SEL ; Select CPU power state as debug information output to IO.
= 0, NOT_SELECT
= 1, SELECT

> 9, 1, CORE1_POWER_STATE_SEL ; Select BIGCORE1 power state as debug information output to IO.
= 0, NOT_SELECT
= 1, SELECT

> 8, 1, CORE0_POWER_STATE_SEL ; Select BIGCORE0 power state as debug information output to IO.
= 0, NOT_SELECT
= 1, SELECT

> 7, 1, CPU7_POWER_STATE_SEL ; Select CPU7 power state as CPU power state.
= 0, NOT_SELECT
= 1, SELECT

> 6, 1, CPU6_POWER_STATE_SEL ; Select CPU6 power state as CPU power state.
= 0, NOT_SELECT
= 1, SELECT

> 5, 1, CPU5_POWER_STATE_SEL ; Select CPU5 power state as CPU power state.
= 0, NOT_SELECT
= 1, SELECT

> 4, 1, CPU4_POWER_STATE_SEL ; Select CPU4 power state as CPU power state.
= 0, NOT_SELECT
= 1, SELECT

> 3, 1, CPU3_POWER_STATE_SEL ; Select CPU3 power state as CPU power state.
= 0, NOT_SELECT
= 1, SELECT

> 2, 1, CPU2_POWER_STATE_SEL ; Select CPU2 power state as CPU power state.
= 0, NOT_SELECT
= 1, SELECT

> 1, 1, CPU1_POWER_STATE_SEL ; Select CPU1 power state as CPU power state.
= 0, NOT_SELECT
= 1, SELECT

> 0, 1, CPU0_POWER_STATE_SEL ; Select CPU0 power state as CPU power state.
= 0, NOT_SELECT
= 1, SELECT

PMU_VOP_SUBPD_PWR_CHAIN_STS = 0x81E4 ; VOP sub-domain power chain status register
> 20, 1, VOP_DSC8K_C0_PWR_STAT, RO ; PD_VOPDSC8K power chain 0 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 19, 1, VOP_DSC8K_C1_PWR_STAT, RO ; PD_VOPDSC8K power chain 1 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 18, 1, VOP_DSC8K_MEM_PWR_STAT, RO ; PD_VOPDSC8K memory power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 17, 1, VOP_DSC4K_C0_PWR_STAT, RO ; PD_VOPDSC4K power chain 0 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 16, 1, VOP_DSC4K_C1_PWR_STAT, RO ; PD_VOPDSC4K power chain 1 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 15, 1, VOP_DSC4K_MEM_PWR_STAT, RO ; PD_VOPDSC4K memory power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 14, 1, VOP_ESMART_C0_PWR_STAT, RO ; PD_VOPESMART power chain 0 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 13, 1, VOP_ESMART_C1_PWR_STAT, RO ; PD_VOPESMART power chain 1 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 12, 1, VOP_ESMART_MEM_PWR_STAT, RO ; PD_VOPESMART memory power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 11, 1, VOP_CLUSTER3_C0_PWR_STAT, RO ; PD_VOPCLUSTER3 power chain 0 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 10, 1, VOP_CLUSTER3_C1_PWR_STAT, RO ; PD_VOPCLUSTER3 power chain 1 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 9, 1, VOP_CLUSTER3_MEM_PWR_STAT, RO ; PD_VOPCLUSTER3 memory power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 8, 1, VOP_CLUSTER2_C0_PWR_STAT, RO ; PD_VOPCLUSTER2 power chain 0 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 7, 1, VOP_CLUSTER2_C1_PWR_STAT, RO ; PD_VOPCLUSTER2 power chain 1 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 6, 1, VOP_CLUSTER2_MEM_PWR_STAT, RO ; PD_VOPCLUSTER2 memory power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 5, 1, VOP_CLUSTER1_C0_PWR_STAT, RO ; PD_VOPCLUSTER1 power chain 0 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 4, 1, VOP_CLUSTER1_C1_PWR_STAT, RO ; PD_VOPCLUSTER1 power chain 1 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 3, 1, VOP_CLUSTER1_MEM_PWR_STAT, RO ; PD_VOPCLUSTER1 memory power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 2, 1, VOP_CLUSTER0_C0_PWR_STAT, RO ; PD_VOPCLUSTER0 power chain 0 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 1, 1, VOP_CLUSTER0_C1_PWR_STAT, RO ; PD_VOPCLUSTER0 power chain 1 power state.
= 0, POWER_DOWN
= 1, POWER_UP

> 0, 1, VOP_CLUSTER0_MEM_PWR_STAT, RO ; PD_VOPCLUSTER0 memory power state.
= 0, POWER_UP
= 1, POWER_DOWN

PMU_PWR_CHAIN0_STS0 = 0x81E8 ; Power domain power chain 0 status register 0
> 31, 1, PD_PCIE_C0_PWR_STAT, RO ; The power state of PD_PCIE power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 30, 1, PD_GMAC_C0_PWR_STAT, RO ; The power state of PD_GMAC power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 29, 1, PD_PHP_C0_PWR_STAT, RO ; The power state of PD_PHP power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 28, 1, PD_AUDIO_C0_PWR_STAT, RO ; The power state of PD_AUDIO power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 27, 1, PD_VO1_C0_PWR_STAT, RO ; The power state of PD_VO1 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 26, 1, PD_VO0_C0_PWR_STAT, RO ; The power state of PD_VO0 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 25, 1, PD_VOP_C0_PWR_STAT, RO ; The power state of PD_VOP power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 24, 1, PD_RGA31_C0_PWR_STAT, RO ; The power state of PD_RGA31 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 23, 1, PD_ISP1_C0_PWR_STAT, RO ; The power state of PD_ISP1 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 22, 1, PD_FEC_C0_PWR_STAT, RO ; The power state of PD_FEC power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 21, 1, PD_VI_C0_PWR_STAT, RO ; The power state of PD_VI power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 20, 1, PD_AV1_C0_PWR_STAT, RO ; The power state of PD_AV1 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 19, 1, PD_RGA30_C0_PWR_STAT, RO ; The power state of PD_RGA30.
= 0, POWER_DOWN
= 1, POWER_UP

> 18, 1, PD_VDPU_C0_PWR_STAT, RO ; The power state of PD_VDPU power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 17, 1, PD_RKVDEC1_C0_PWR_STAT, RO ; The power state of PD_RKVDEC1 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 16, 1, PD_RKVDEC0_C0_PWR_STAT, RO ; The power state of PD_RKVDEC0 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 15, 1, PD_VENC1_C0_PWR_STAT, RO ; The power state of PD_VENC1 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 14, 1, PD_VENC0_C0_PWR_STAT, RO ; The power state of PD_VENC0 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 13, 1, PD_NPU2_C0_PWR_STAT, RO ; The power state of PD_NPU2 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 12, 1, PD_NPU1_C0_PWR_STAT, RO ; The power state of PD_NPU1 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 11, 1, PD_NPUTOP_C0_PWR_STAT, RO ; The power state of PD_NPUTOP power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 7, 1, PD_CPU_7_C0_PWR_STAT, RO ; The power state of PD_CPU_7 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 6, 1, PD_CPU_6_C0_PWR_STAT, RO ; The power state of PD_CPU_6 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 5, 1, PD_CPU_5_C0_PWR_STAT, RO ; The power state of PD_CPU_5 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 4, 1, PD_CPU_4_C0_PWR_STAT, RO ; The power state of PD_CPU_4 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 3, 1, PD_CPU_3_C0_PWR_STAT, RO ; The power state of PD_CPU_3 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 2, 1, PD_CPU_2_C0_PWR_STAT, RO ; The power state of PD_CPU_2 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 1, 1, PD_CPU_1_C0_PWR_STAT, RO ; The power state of PD_CPU_1 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 0, 1, PD_CPU_0_C0_PWR_STAT, RO ; The power state of PD_CPU_0 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

PMU_PWR_CHAIN0_STS1 = 0x81EC ; Power domain power chain 0 status register 1
> 7, 1, PD_CENTER_C0_PWR_STAT, RO ; The power state of PD_CENTER power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 6, 1, PD_CRYPTO_C0_PWR_STAT, RO ; The power state of PD_CRYPTO power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 5, 1, PD_SDMMC_C0_PWR_STAT, RO ; The power state of PD_SDMMC power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 4, 1, PD_SECURE_C0_PWR_STAT, RO ; The power state of PD_SECURE power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 3, 1, PD_USB_C0_PWR_STAT, RO ; The power state of PD_USB power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 2, 1, PD_SDIO_C0_PWR_STAT, RO ; The power state of PD_SDIO power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 1, 1, PD_NVM0_C0_PWR_STAT, RO ; The power state of PD_NVM0 power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

> 0, 1, PD_NVM_C0_PWR_STAT, RO ; The power state of PD_NVM power chain 0.
= 0, POWER_DOWN
= 1, POWER_UP

PMU_PWR_CHAIN1_STS0 = 0x81F0 ; Power domain power chain 1 status register 0
> 31, 1, PD_PCIE_C1_PWR_STAT, RO ; The power state of PD_PCIE power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 30, 1, PD_GMAC_C1_PWR_STAT, RO ; The power state of PD_GMAC power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 29, 1, PD_PHP_C1_PWR_STAT, RO ; The power state of PD_PHP power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 28, 1, PD_AUDIO_C1_PWR_STAT, RO ; The power state of PD_AUDIO power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 27, 1, PD_VO1_C1_PWR_STAT, RO ; The power state of PD_VO1 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 26, 1, PD_VO0_C1_PWR_STAT, RO ; The power state of PD_VO0 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 25, 1, PD_VOP_C1_PWR_STAT, RO ; The power state of PD_VOP power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 24, 1, PD_RGA31_C1_PWR_STAT, RO ; The power state of PD_RGA31 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 23, 1, PD_ISP1_C1_PWR_STAT, RO ; The power state of PD_ISP1 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 22, 1, PD_FEC_C1_PWR_STAT, RO ; The power state of PD_FEC power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 21, 1, PD_VI_C1_PWR_STAT, RO ; The power state of PD_VI power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 20, 1, PD_AV1_C1_PWR_STAT, RO ; The power state of PD_AV1 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 19, 1, PD_RGA30_C1_PWR_STAT, RO ; The power state of PD_RGA30.
= 0, POWER_DOWN
= 1, POWER_UP

> 18, 1, PD_VDPU_C1_PWR_STAT, RO ; The power state of PD_VDPU power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 17, 1, PD_RKVDEC1_C1_PWR_STAT, RO ; The power state of PD_RKVDEC1 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 16, 1, PD_RKVDEC0_C1_PWR_STAT, RO ; The power state of PD_RKVDEC0 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 15, 1, PD_VENC1_C1_PWR_STAT, RO ; The power state of PD_VENC1 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 14, 1, PD_VENC0_C1_PWR_STAT, RO ; The power state of PD_VENC0 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 13, 1, PD_NPU2_C1_PWR_STAT, RO ; The power state of PD_NPU2 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 12, 1, PD_NPU1_C1_PWR_STAT, RO ; The power state of PD_NPU1 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 11, 1, PD_NPUTOP_C1_PWR_STAT, RO ; The power state of PD_NPUTOP power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 7, 1, PD_CPU_7_C1_PWR_STAT, RO ; The power state of PD_CPU_7 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 6, 1, PD_CPU_6_C1_PWR_STAT, RO ; The power state of PD_CPU_6 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 5, 1, PD_CPU_5_C1_PWR_STAT, RO ; The power state of PD_CPU_5 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 4, 1, PD_CPU_4_C1_PWR_STAT, RO ; The power state of PD_CPU_4 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 3, 1, PD_CPU_3_C1_PWR_STAT, RO ; The power state of PD_CPU_3 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 2, 1, PD_CPU_2_C1_PWR_STAT, RO ; The power state of PD_CPU_2 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 1, 1, PD_CPU_1_C1_PWR_STAT, RO ; The power state of PD_CPU_1 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 0, 1, PD_CPU_0_C1_PWR_STAT, RO ; The power state of PD_CPU_0 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

PMU_PWR_CHAIN1_STS1 = 0x81F4 ; Power domain power chain 1 status register 1
> 7, 1, PD_CENTER_C1_PWR_STAT, RO ; The power state of PD_CENTER power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 6, 1, PD_CRYPTO_C1_PWR_STAT, RO ; The power state of PD_CRYPTO power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 5, 1, PD_SDMMC_C1_PWR_STAT, RO ; The power state of PD_SDMMC power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 4, 1, PD_SECURE_C1_PWR_STAT, RO ; The power state of PD_SECURE power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 3, 1, PD_USB_C1_PWR_STAT, RO ; The power state of PD_USB power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 2, 1, PD_SDIO_C1_PWR_STAT, RO ; The power state of PD_SDIO power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 1, 1, PD_NVM0_C1_PWR_STAT, RO ; The power state of PD_NVM0 power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

> 0, 1, PD_NVM_C1_PWR_STAT, RO ; The power state of PD_NVM power chain 1.
= 0, POWER_DOWN
= 1, POWER_UP

PMU_PWR_MEM_STS0 = 0x81F8 ; Power domain memory power status register 0
> 31, 1, PD_PCIE_MEM_PWR_STAT, RO ; The power state of PD_PCIE memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 30, 1, PD_GMAC_MEM_PWR_STAT, RO ; The power state of PD_GMAC memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 29, 1, PD_PHP_MEM_PWR_STAT, RO ; The power state of PD_PHP memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 28, 1, PD_AUDIO_MEM_PWR_STAT, RO ; The power state of PD_AUDIO memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 27, 1, PD_VO1_MEM_PWR_STAT, RO ; The power state of PD_VO1 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 26, 1, PD_VO0_MEM_PWR_STAT, RO ; The power state of PD_VO0 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 25, 1, PD_VOP_MEM_PWR_STAT, RO ; The power state of PD_VOP memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 24, 1, PD_RGA31_MEM_PWR_STAT, RO ; The power state of PD_RGA31 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 23, 1, PD_ISP1_MEM_PWR_STAT, RO ; The power state of PD_ISP1 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 22, 1, PD_FEC_MEM_PWR_STAT, RO ; The power state of PD_FEC memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 21, 1, PD_VI_MEM_PWR_STAT, RO ; The power state of PD_VI memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 20, 1, PD_AV1_MEM_PWR_STAT, RO ; The power state of PD_AV1 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 19, 1, PD_RGA30_MEM_PWR_STAT, RO ; The power state of PD_RGA30 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 17, 1, PD_RKVDEC1_MEM_PWR_STAT, RO ; The power state of PD_RKVDEC1 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 16, 1, PD_RKVDEC0_MEM_PWR_STAT, RO ; The power state of PD_RKVDEC0 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 15, 1, PD_VENC1_MEM_PWR_STAT, RO ; The power state of PD_VENC1 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 14, 1, PD_VENC0_MEM_PWR_STAT, RO ; The power state of PD_VENC0 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 13, 1, PD_NPU2_MEM_PWR_STAT, RO ; The power state of PD_NPU2 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 12, 1, PD_NPU1_MEM_PWR_STAT, RO ; The power state of PD_NPU1 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 11, 1, PD_NPUTOP_MEM_PWR_STAT, RO ; The power state of PD_NPUTOP memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 7, 1, PD_CPU_7_MEM_PWR_STAT, RO ; The power state of PD_CPU_7 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 6, 1, PD_CPU_6_MEM_PWR_STAT, RO ; The power state of PD_CPU_6 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 5, 1, PD_CPU_5_MEM_PWR_STAT, RO ; The power state of PD_CPU_5 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 4, 1, PD_CPU_4_MEM_PWR_STAT, RO ; The power state of PD_CPU_4 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 3, 1, PD_CPU_3_MEM_PWR_STAT, RO ; The power state of PD_CPU_3 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 2, 1, PD_CPU_2_MEM_PWR_STAT, RO ; The power state of PD_CPU_2 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 1, 1, PD_CPU_1_MEM_PWR_STAT, RO ; The power state of PD_CPU_1 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 0, 1, PD_CPU_0_MEM_PWR_STAT, RO ; The power state of PD_CPU_0 memory.
= 0, POWER_UP
= 1, POWER_DOWN

PMU_PWR_MEM_STS1 = 0x81FC ; Power domain memory power status register 1
> 14, 1, PD_DSU_MEM_PWR_STAT4, RO ; used to indicate other memory power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 13, 1, PD_DSU_MEM_PWR_STAT3, RO ; used to indicate "L3 Tag ways 8~11, L3 Data portion 1 RAMs" memory power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 12, 1, PD_DSU_MEM_PWR_STAT2, RO ; used to indicate "L3 Tag ways 4~7" memory power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 11, 1, PD_DSU_MEM_PWR_STAT1, RO ; used to indicate "L3 Tag ways 0~3, L3 Data portion 0, and L3 Victim RAMs" memory state.
= 0, POWER_UP
= 1, POWER_DOWN

> 10, 1, PD_DSU_MEM_PWR_STAT0, RO ; used to indicate "Snoop filter and LTDB RAMs" memory power state.
= 0, POWER_UP
= 1, POWER_DOWN

> 9, 1, PD_DDR23_MEM_PWR_STAT, RO ; The power state of VD_DDR23 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 8, 1, PD_DDR01_MEM_PWR_STAT, RO ; The power state of VD_DDR01 memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 7, 1, PD_CENTER_MEM_PWR_STAT, RO ; The power state of PD_CENTER memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 6, 1, PD_CRYPTO_MEM_PWR_STAT, RO ; The power state of PD_CRYPTO memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 5, 1, PD_SDMMC_MEM_PWR_STAT, RO ; The power state of PD_SDMMC memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 3, 1, PD_USB_MEM_PWR_STAT, RO ; The power state of PD_USB memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 2, 1, PD_SDIO_MEM_PWR_STAT, RO ; The power state of PD_SDIO memory.
= 0, POWER_UP
= 1, POWER_DOWN

> 1, 1, PD_NVM0_MEM_PWR_STAT, RO ; The power state of PD_NVM0 memory.
= 0, POWER_UP
= 1, POWER_DOWN

PMU_BISR_CON0 = 0x8200 ; Memory repair control register 0
> 11, 1, BISR_INITRSTN_DIS ; Disable initial reset for memory repair logic.
= 0, ENABLE
= 1, DISABLE

> 10, 1, BISR_SFT_ENA ; Enable memory repair control by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, BISR_RESETN_SFT ; Generate bisr_resetN by software.

> 8, 1, BISR_REPAIR_MODE ; Memory repair mode.
= 0, SERIAL ; Serial repair mode. In this mode, memory repair will start after power domain is power up, not need to wait for other domain power up. If multi domains are power up at the same time, the repair is executed according to the repair group order.
= 1, PARALLEL ; Parallel repair mode. In this mode, memory repair will not start until all specified power domains are power up.

> 7, 1, BISR_TIMEOUT_ENA ; Enable memory repair timeout counter.
= 0, DISABLE
= 1, ENABLE

> 6, 1, BISR_CLKGATE_SFTENA ; Enable memory repair clock gating by software. If asserted, memory repair clock is gated.
= 0, DISABLE
= 1, ENABLE

> 5, 1, BISR_CLKGATE_ENA ; Enable memory repair auto clock gating by hardware. If asserted, memory repair clock is auto gated when memory repair is idle.
= 0, DISABLE
= 1, ENABLE

> 1, 1, BISR_PDGDONE ; PDGDone come from bisr_PDGDone, controlled by hardware. Only one bit can be set to 1 at a time.
> 2, 1, SFT_PDGDONE ; PDGDone come from sft_PDGDone (pd_xx_pdgdone_sftena), controlled by software. Only one bit can be set to 1 at a time.
> 3, 1, BISR_DONE ; PDGDone come from bisr_Done, controlled by hardware. Only one bit can be set to 1 at a time.
> 4, 1, BISR_TIMEOUT ; PDGDone come from bisr_timeout, controlled by hardware. Only one bit can be set to 1 at a time.

> 0, 1, BISR_INIT ; Enable memory repair initialization. When asserted, the chip will startup memory repair for memory of power on if external memory repair information is ready. It should be set to 0 if chip is reset by software.
= 0, DISABLE
= 1, ENABLE

PMU_BISR_CON1 = 0x8204 ; Memory repair control register 1
> 15, 1, PD_RGA31_REPAIR_ENA ; Enable memory repair for PD_RGA31 by hardware.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_ISP1_REPAIR_ENA ; Enable memory repair for PD_ISP1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_FEC_REPAIR_ENA ; Enable memory repair for PD_FEC by hardware.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_VI_REPAIR_ENA ; Enable memory repair for PD_VI by hardware.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_AV1_REPAIR_ENA ; Enable memory repair for PD_AV1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_RGA30_REPAIR_ENA ; Enable memory repair for PD_RGA30 by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_VDPU_REPAIR_ENA ; Enable memory repair for PD_VDPU by hardware.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_RKVDEC1_REPAIR_ENA ; Enable memory repair for PD_RKVDEC1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_RKVDEC0_REPAIR_ENA ; Enable memory repair for PD_RKVDEC0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_VENC1_REPAIR_ENA ; Enable memory repair for PD_VENC1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_VENC0_REPAIR_ENA ; Enable memory repair for PD_VENC0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_NPU2_REPAIR_ENA ; Enable memory repair for PD_NPU2 by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_NPU1_REPAIR_ENA ; Enable memory repair for PD_NPU1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_NPUTOP_REPAIR_ENA ; Enable memory repair for PD_NPUTOP by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_GPU_BISR_ENA ; Enable memory repair for VD_GPU by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_BISR_CON2 = 0x8208 ; Memory repair control register 2
> 15, 1, PD_BUS_REPAIR_ENA ; Enable memory repair for PD_BUS by hardware.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_DDR23_REPAIR_ENA ; Enable memory repair for VD_DDR23 by hardware.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_DDR01_REPAIR_ENA ; Enable memory repair for VD_DDR01 by hardware.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_CENTER_REPAIR_ENA ; Enable memory repair for PD_CENTER by hardware.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_CRYPTO_REPAIR_ENA ; Enable memory repair for PD_CRYPTO by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_SDMMC_REPAIR_ENA ; Enable memory repair for PD_SDMMC by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_USB_REPAIR_ENA ; Enable memory repair for PD_USB by hardware.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_SDIO_REPAIR_ENA ; Enable memory repair for PD_SDIO by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_NVM0_REPAIR_ENA ; Enable memory repair for PD_NVM0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_PCIE_REPAIR_ENA ; Enable memory repair for PD_PCIE by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_GMAC_REPAIR_ENA ; Enable memory repair for PD_GMAC by hardware.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_PHP_REPAIR_ENA ; Enable memory repair for PD_PHP by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_AUDIO_REPAIR_ENA ; Enable memory repair for PD_AUDIO by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_VO1_REPAIR_ENA ; Enable memory repair for PD_VO1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_VO0_REPAIR_ENA ; Enable memory repair for PD_VO0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_VOP_REPAIR_ENA ; Enable memory repair for PD_VOP by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_BISR_CON3 = 0x820C ; Memory repair control register 3
> 15, 1, PD_VOPESMART_REPAIR_ENA ; Enable memory repair for PD_VOPESMART by hardware.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_VOPDSC4K_REPAIR_ENA ; Enable memory repair for PD_VOPDSC4K by hardware.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_VOPDSC8K_REPAIR_ENA ; Enable memory repair for PD_VOPDSC8K by hardware.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_VOPCLUSTER3_REPAIR_ENA ; Enable memory repair for PD_VOPCLUSTER3 by hardware.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_VOPCLUSTER2_REPAIR_ENA ; Enable memory repair for PD_VOPCLUSTER2 by hardware.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_VOPCLUSTER1_REPAIR_ENA ; Enable memory repair for PD_VOPCLUSTER1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_VOPCLUSTER0_REPAIR_ENA ; Enable memory repair for PD_VOPCLUSTER0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_CPU0_REPAIR_ENA ; Enable memory repair for PD_CPU0 by hardware.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_CPU1_REPAIR_ENA ; Enable memory repair for PD_CPU1 by hardware.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_CPU2_REPAIR_ENA ; Enable memory repair for PD_CPU2 by hardware.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_CPU3_REPAIR_ENA ; Enable memory repair for PD_CPU3 by hardware.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_CPU4_REPAIR_ENA ; Enable memory repair for PD_CPU4 by hardware.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_CPU5_REPAIR_ENA ; Enable memory repair for PD_CPU5 by hardware.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_CPU6_REPAIR_ENA ; Enable memory repair for PD_CPU6 by hardware.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_CPU7_REPAIR_ENA ; Enable memory repair for PD_CPU7 by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_DSU_REPAIR_ENA ; Enable memory repair for PD_DSU by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_BISR_CON4 = 0x8210 ; Memory repair control register 4
> 15, 1, PD_RGA31_REPAIR_SFTENA ; Enable memory repair for PD_RGA31 by software.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_ISP1_REPAIR_SFTENA ; Enable memory repair for PD_ISP1 by software.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_FEC_REPAIR_SFTENA ; Enable memory repair for PD_FEC by software.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_VI_REPAIR_SFTENA ; Enable memory repair for PD_VI by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_AV1_REPAIR_SFTENA ; Enable memory repair for PD_AV1 by software.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_RGA30_REPAIR_SFTENA ; Enable memory repair for PD_RGA30 by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_VDPU_REPAIR_SFTENA ; Enable memory repair for PD_VDPU by software.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_RKVDEC1_REPAIR_SFTENA ; Enable memory repair for PD_RKVDEC1 by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_RKVDEC0_REPAIR_SFTENA ; Enable memory repair for PD_RKVDEC0 by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_VENC1_REPAIR_SFTENA ; Enable memory repair for PD_VENC1 by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_VENC0_REPAIR_SFTENA ; Enable memory repair for PD_VENC0 by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_NPU2_REPAIR_SFTENA ; Enable memory repair for PD_NPU2 by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_NPU1_REPAIR_SFTENA ; Enable memory repair for PD_NPU1 by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_NPUTOP_REPAIR_SFTENA ; Enable memory repair for PD_NPUTOP by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_GPU_BISR_SFTENA ; Enable memory repair for VD_GPU by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_PMU1_REPAIR_SFTENA ; Enable memory repair for PD_PMU1 by software.
= 0, DISABLE
= 1, ENABLE

PMU_BISR_CON5 = 0x8214 ; Memory repair control register 5
> 15, 1, PD_BUS_REPAIR_SFTENA ; Enable memory repair for PD_BUS by software.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_DDR23_REPAIR_SFTENA ; Enable memory repair for VD_DDR23 by software.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_DDR01_REPAIR_SFTENA ; Enable memory repair for VD_DDR01 by software.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_CENTER_REPAIR_SFTENA ; Enable memory repair for PD_CENTER by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_CRYPTO_REPAIR_SFTENA ; Enable memory repair for PD_CRYPTO by software.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_SDMMC_REPAIR_SFTENA ; Enable memory repair for PD_SDMMC by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_USB_REPAIR_SFTENA ; Enable memory repair for PD_USB by software.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_SDIO_REPAIR_SFTENA ; Enable memory repair for PD_SDIO by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_NVM0_REPAIR_SFTENA ; Enable memory repair for PD_NVM0 by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_PCIE_REPAIR_SFTENA ; Enable memory repair for PD_PCIE by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_GMAC_REPAIR_SFTENA ; Enable memory repair for PD_GMAC by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_PHP_REPAIR_SFTENA ; Enable memory repair for PD_PHP by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_AUDIO_REPAIR_SFTENA ; Enable memory repair for PD_AUDIO by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_VO1_REPAIR_SFTENA ; Enable memory repair for PD_VO1 by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_VO0_REPAIR_SFTENA ; Enable memory repair for PD_VO0 by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_VOP_REPAIR_SFTENA ; Enable memory repair for PD_VOP by software.
= 0, DISABLE
= 1, ENABLE

PMU_BISR_CON6 = 0x8218 ; Memory repair control register 6
> 15, 1, PD_VOPESMART_REPAIR_SFTENA ; Enable memory repair for PD_VOPESMART by software.
= 0, DISABLE
= 1, ENABLE

> 14, 1, PD_VOPDSC4K_REPAIR_SFTENA ; Enable memory repair for PD_VOPDSC4K by software.
= 0, DISABLE
= 1, ENABLE

> 13, 1, PD_VOPDSC8K_REPAIR_SFTENA ; Enable memory repair for PD_VOPDSC8K by software.
= 0, DISABLE
= 1, ENABLE

> 12, 1, PD_VOPCLUSTER3_REPAIR_SFTENA ; Enable memory repair for PD_VOPCLUSTER3 by software.
= 0, DISABLE
= 1, ENABLE

> 11, 1, PD_VOPCLUSTER2_REPAIR_SFTENA ; Enable memory repair for PD_VOPCLUSTER2 by software.
= 0, DISABLE
= 1, ENABLE

> 10, 1, PD_VOPCLUSTER1_REPAIR_SFTENA ; Enable memory repair for PD_VOPCLUSTER1 by software.
= 0, DISABLE
= 1, ENABLE

> 9, 1, PD_VOPCLUSTER0_REPAIR_SFTENA ; Enable memory repair for PD_VOPCLUSTER0 by software.
= 0, DISABLE
= 1, ENABLE

> 8, 1, PD_CPU0_REPAIR_SFTENA ; Enable memory repair for PD_CPU0 by software.
= 0, DISABLE
= 1, ENABLE

> 7, 1, PD_CPU1_REPAIR_SFTENA ; Enable memory repair for PD_CPU1 by software.
= 0, DISABLE
= 1, ENABLE

> 6, 1, PD_CPU2_REPAIR_SFTENA ; Enable memory repair for PD_CPU2 by software.
= 0, DISABLE
= 1, ENABLE

> 5, 1, PD_CPU3_REPAIR_SFTENA ; Enable memory repair for PD_CPU3 by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, PD_CPU4_REPAIR_SFTENA ; Enable memory repair for PD_CPU4 by software.
= 0, DISABLE
= 1, ENABLE

> 3, 1, PD_CPU5_REPAIR_SFTENA ; Enable memory repair for PD_CPU5 by software.
= 0, DISABLE
= 1, ENABLE

> 2, 1, PD_CPU6_REPAIR_SFTENA ; Enable memory repair for PD_CPU6 by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PD_CPU7_REPAIR_SFTENA ; Enable memory repair for PD_CPU7 by software.
= 0, DISABLE
= 1, ENABLE

> 0, 1, PD_DSU_REPAIR_SFTENA ; Enable memory repair for PD_DSU by software.
= 0, DISABLE
= 1, ENABLE

PMU_BISR_CON7 = 0x821C ; Memory repair control register 7
> 15, 1, PD_RGA31_PDGDONE_SFTENA ; Configure repair done for PD_RGA31 by software.
= 0, INACTIVE
= 1, ACTIVE

> 14, 1, PD_ISP1_PDGDONE_SFTENA ; Configure repair done for PD_ISP1 by software.
= 0, INACTIVE
= 1, ACTIVE

> 13, 1, PD_FEC_PDGDONE_SFTENA ; Configure repair done for PD_FEC by software.
= 0, INACTIVE
= 1, ACTIVE

> 12, 1, PD_VI_PDGDONE_SFTENA ; Configure repair done for PD_VI by software.
= 0, INACTIVE
= 1, ACTIVE

> 11, 1, PD_AV1_PDGDONE_SFTENA ; Configure repair done for PD_AV1 by software.
= 0, INACTIVE
= 1, ACTIVE

> 10, 1, PD_RGA30_PDGDONE_SFTENA ; Configure repair done for PD_RGA30 by software.
= 0, INACTIVE
= 1, ACTIVE

> 9, 1, PD_VDPU_PDGDONE_SFTENA ; Configure repair done for PD_VDPU by software.
= 0, INACTIVE
= 1, ACTIVE

> 8, 1, PD_RKVDEC1_PDGDONE_SFTENA ; Configure repair done for PD_RKVDEC1 by software.
= 0, INACTIVE
= 1, ACTIVE

> 7, 1, PD_RKVDEC0_PDGDONE_SFTENA ; Configure repair done for PD_RKVDEC0 by software.
= 0, INACTIVE
= 1, ACTIVE

> 6, 1, PD_VENC1_PDGDONE_SFTENA ; Configure repair done for PD_VENC1 by software.
= 0, INACTIVE
= 1, ACTIVE

> 5, 1, PD_VENC0_PDGDONE_SFTENA ; Configure repair done for PD_VENC0 by software.
= 0, INACTIVE
= 1, ACTIVE

> 4, 1, PD_NPU2_PDGDONE_SFTENA ; Configure repair done for PD_NPU2 by software.
= 0, INACTIVE
= 1, ACTIVE

> 3, 1, PD_NPU1_PDGDONE_SFTENA ; Configure repair done for PD_NPU1 by software.
= 0, INACTIVE
= 1, ACTIVE

> 2, 1, PD_NPUTOP_PDGDONE_SFTENA ; Configure repair done for PD_NPUTOP by software.
= 0, INACTIVE
= 1, ACTIVE

> 1, 1, PD_GPU_PDGDONE_SFTENA ; Configure repair done for VD_GPU by software.
= 0, INACTIVE
= 1, ACTIVE

> 0, 1, PD_PMU1_PDGDONE_SFTENA ; Configure repair done for PD_PMU1 by software.
= 0, INACTIVE
= 1, ACTIVE

PMU_BISR_CON8 = 0x8220 ; Memory repair control register 8
> 15, 1, PD_BUS_PDGDONE_SFTENA ; Configure repair done for PD_BUS by software.
= 0, INACTIVE
= 1, ACTIVE

> 14, 1, PD_DDR23_PDGDONE_SFTENA ; Configure repair done for VD_DDR23 by software.
= 0, INACTIVE
= 1, ACTIVE

> 13, 1, PD_DDR01_PDGDONE_SFTENA ; Configure repair done for VD_DDR01 by software.
= 0, INACTIVE
= 1, ACTIVE

> 12, 1, PD_CENTER_PDGDONE_SFTENA ; Configure repair done for PD_CENTER by software.
= 0, INACTIVE
= 1, ACTIVE

> 11, 1, PD_CRYPTO_PDGDONE_SFTENA ; Configure repair done for PD_CRYPTO by software.
= 0, INACTIVE
= 1, ACTIVE

> 10, 1, PD_SDMMC_PDGDONE_SFTENA ; Configure repair done for PD_SDMMC by software.
= 0, INACTIVE
= 1, ACTIVE

> 9, 1, PD_USB_PDGDONE_SFTENA ; Configure repair done for PD_USB by software.
= 0, INACTIVE
= 1, ACTIVE

> 8, 1, PD_SDIO_PDGDONE_SFTENA ; Configure repair done for PD_SDIO by software.
= 0, INACTIVE
= 1, ACTIVE

> 7, 1, PD_NVM0_PDGDONE_SFTENA ; Configure repair done for PD_NVM0 by software.
= 0, INACTIVE
= 1, ACTIVE

> 6, 1, PD_PCIE_PDGDONE_SFTENA ; Configure repair done for PD_PCIE by software.
= 0, INACTIVE
= 1, ACTIVE

> 5, 1, PD_GMAC_PDGDONE_SFTENA ; Configure repair done for PD_GMAC by software.
= 0, INACTIVE
= 1, ACTIVE

> 4, 1, PD_PHP_PDGDONE_SFTENA ; Configure repair done for PD_PHP by software.
= 0, INACTIVE
= 1, ACTIVE

> 3, 1, PD_AUDIO_PDGDONE_SFTENA ; Configure repair done for PD_AUDIO by software.
= 0, INACTIVE
= 1, ACTIVE

> 2, 1, PD_VO1_PDGDONE_SFTENA ; Configure repair done for PD_VO1 by software.
= 0, INACTIVE
= 1, ACTIVE

> 1, 1, PD_VO0_PDGDONE_SFTENA ; Configure repair done for PD_VO0 by software.
= 0, INACTIVE
= 1, ACTIVE

> 0, 1, PD_VOP_PDGDONE_SFTENA ; Active repair PD_VOP by software.
= 0, INACTIVE
= 1, ACTIVE

PMU_BISR_CON9 = 0x8224 ; Memory repair control register 9
> 15, 1, PD_VOPESMART_PDGDONE_SFTENA ; Configure repair done for PD_VOPESMART by software.
= 0, INACTIVE
= 1, ACTIVE

> 14, 1, PD_VOPDSC4K_PDGDONE_SFTENA ; Configure repair done for PD_VOPDSC4K by software.
= 0, INACTIVE
= 1, ACTIVE

> 13, 1, PD_VOPDSC8K_PDGDONE_SFTENA ; Configure repair done for PD_VOPDSC8K by software.
= 0, INACTIVE
= 1, ACTIVE

> 12, 1, PD_VOPCLUSTER3_PDGDONE_SFTENA ; Configure repair done for PD_VOPCLUSTER3 by software.
= 0, INACTIVE
= 1, ACTIVE

> 11, 1, PD_VOPCLUSTER2_PDGDONE_SFTENA ; Configure repair done for PD_VOPCLUSTER2 by software.
= 0, INACTIVE
= 1, ACTIVE

> 10, 1, PD_VOPCLUSTER1_PDGDONE_SFTENA ; Configure repair done for PD_VOPCLUSTER1 by software.
= 0, INACTIVE
= 1, ACTIVE

> 9, 1, PD_VOPCLUSTER0_PDGDONE_SFTENA ; Configure repair done for PD_VOPCLUSTER0 by software.
= 0, INACTIVE
= 1, ACTIVE

> 8, 1, PD_CPU0_PDGDONE_SFTENA ; Configure repair done for PD_CPU0 by software.
= 0, INACTIVE
= 1, ACTIVE

> 7, 1, PD_CPU1_PDGDONE_SFTENA ; Configure repair done for PD_CPU1 by software.
= 0, INACTIVE
= 1, ACTIVE

> 6, 1, PD_CPU2_PDGDONE_SFTENA ; Configure repair done for PD_CPU2 by software.
= 0, INACTIVE
= 1, ACTIVE

> 5, 1, PD_CPU3_PDGDONE_SFTENA ; Configure repair done for PD_CPU3 by software.
= 0, INACTIVE
= 1, ACTIVE

> 4, 1, PD_CPU4_PDGDONE_SFTENA ; Configure repair done for PD_CPU4 by software.
= 0, INACTIVE
= 1, ACTIVE

> 3, 1, PD_CPU5_PDGDONE_SFTENA ; Configure repair done for PD_CPU5 by software.
= 0, INACTIVE
= 1, ACTIVE

> 2, 1, PD_CPU6_PDGDONE_SFTENA ; Configure repair done for PD_CPU6 by software.
= 0, INACTIVE
= 1, ACTIVE

> 1, 1, PD_CPU7_PDGDONE_SFTENA ; Configure repair done for PD_CPU7 by software.
= 0, INACTIVE
= 1, ACTIVE

> 0, 1, PD_DSU_PDGDONE_SFTENA ; Configure repair done for PD_DSU by software.
= 0, INACTIVE
= 1, ACTIVE

PMU_BISR_CON10 = 0x8228 ; Memory repair control register 10
> 16, 16, WRITE_ENABLE, WO ; Write Inactive for lower 16 bits, each bit is individual.
= 0, ACTIVE ; Write access Active
= 1, INACTIVE ; Write access Inactive

> 15, 1, PD_RGA31_INITRSTN_SFTENA ; Configure initial reset for PD_RGA31 by software.
= 0, ACTIVE
= 1, INACTIVE

> 14, 1, PD_ISP1_INITRSTN_SFTENA ; Configure initial reset for PD_ISP1 by software.
= 0, ACTIVE
= 1, INACTIVE

> 13, 1, PD_FEC_INITRSTN_SFTENA ; Configure initial reset for PD_FEC by software.
= 0, ACTIVE
= 1, INACTIVE

> 12, 1, PD_VI_INITRSTN_SFTENA ; Configure initial reset for PD_VI by software.
= 0, ACTIVE
= 1, INACTIVE

> 11, 1, PD_AV1_INITRSTN_SFTENA ; Configure initial reset for PD_AV1 by software.
= 0, ACTIVE
= 1, INACTIVE

> 10, 1, PD_RGA30_INITRSTN_SFTENA ; Configure initial reset for PD_RGA30 by software.
= 0, ACTIVE
= 1, INACTIVE

> 9, 1, PD_VDPU_INITRSTN_SFTENA ; Configure initial reset for PD_VDPU by software.
= 0, ACTIVE
= 1, INACTIVE

> 8, 1, PD_RKVDEC1_INITRSTN_SFTENA ; Configure initial reset for PD_RKVDEC1 by software.
= 0, ACTIVE
= 1, INACTIVE

> 7, 1, PD_RKVDEC0_INITRSTN_SFTENA ; Configure initial reset for PD_RKVDEC0 by software.
= 0, ACTIVE
= 1, INACTIVE

> 6, 1, PD_VENC1_INITRSTN_SFTENA ; Configure initial reset for PD_VENC1 by software.
= 0, ACTIVE
= 1, INACTIVE

> 5, 1, PD_VENC0_INITRSTN_SFTENA ; Configure initial reset for PD_VENC0 by software.
= 0, ACTIVE
= 1, INACTIVE

> 4, 1, PD_NPU2_INITRSTN_SFTENA ; Configure initial reset for PD_NPU2 by software.
= 0, ACTIVE
= 1, INACTIVE

> 3, 1, PD_NPU1_INITRSTN_SFTENA ; Configure initial reset for PD_NPU1 by software.
= 0, ACTIVE
= 1, INACTIVE

> 2, 1, PD_NPUTOP_INITRSTN_SFTENA ; Configure initial reset for PD_NPUTOP by software.
= 0, ACTIVE
= 1, INACTIVE

> 1, 1, PD_GPU_INITRSTN_SFTENA ; Configure initial reset for PD_PMU1 by software.
= 0, ACTIVE
= 1, INACTIVE

> 0, 1, PD_PMU1_INITRSTN_SFTENA ; Configure initial reset for PD_PMU1 by software.
= 0, ACTIVE
= 1, INACTIVE

PMU_BISR_CON11 = 0x822C ; Memory repair control register 11
> 16, 16, WRITE_ENABLE, WO ; Write Inactive for lower 16 bits, each bit is individual.
= 0, ACTIVE ; Write access Active
= 1, INACTIVE ; Write access Inactive

> 15, 1, PD_BUS_INITRSTN_SFTENA ; Configure initial reset for PD_BUS by software.
= 0, ACTIVE
= 1, INACTIVE

> 14, 1, PD_DDR23_INITRSTN_SFTENA ; Configure initial reset for VD_DDR23 by software.
= 0, ACTIVE
= 1, INACTIVE

> 13, 1, PD_DDR01_INITRSTN_SFTENA ; Configure initial reset for VD_DDR01 by software.
= 0, ACTIVE
= 1, INACTIVE

> 12, 1, PD_CENTER_INITRSTN_SFTENA ; Configure initial reset for PD_CENTER by software.
= 0, ACTIVE
= 1, INACTIVE

> 11, 1, PD_CRYPTO_INITRSTN_SFTENA ; Configure initial reset for PD_CRYPTO by software.
= 0, ACTIVE
= 1, INACTIVE

> 10, 1, PD_SDMMC_INITRSTN_SFTENA ; Configure initial reset for PD_SDMMC by software.
= 0, ACTIVE
= 1, INACTIVE

> 9, 1, PD_USB_INITRSTN_SFTENA ; Configure initial reset for PD_USB by software.
= 0, ACTIVE
= 1, INACTIVE

> 8, 1, PD_SDIO_INITRSTN_SFTENA ; Configure initial reset for PD_SDIO by software.
= 0, ACTIVE
= 1, INACTIVE

> 7, 1, PD_NVM0_INITRSTN_SFTENA ; Configure initial reset for PD_NVM0 by software.
= 0, ACTIVE
= 1, INACTIVE

> 6, 1, PD_PCIE_INITRSTN_SFTENA ; Configure initial reset for PD_PCIE by software.
= 0, ACTIVE
= 1, INACTIVE

> 5, 1, PD_GMAC_INITRSTN_SFTENA ; Configure initial reset for PD_GMAC by software.
= 0, ACTIVE
= 1, INACTIVE

> 4, 1, PD_PHP_INITRSTN_SFTENA ; Configure initial reset for PD_PHP by software.
= 0, ACTIVE
= 1, INACTIVE

> 3, 1, PD_AUDIO_INITRSTN_SFTENA ; Configure initial reset for PD_AUDIO by software.
= 0, ACTIVE
= 1, INACTIVE

> 2, 1, PD_VO1_INITRSTN_SFTENA ; Configure initial reset for PD_VO1 by software.
= 0, ACTIVE
= 1, INACTIVE

> 1, 1, PD_VO0_INITRSTN_SFTENA ; Configure initial reset for PD_VO0 by software.
= 0, ACTIVE
= 1, INACTIVE

> 0, 1, PD_VOP_INITRSTN_SFTENA ; Configure initial reset for PD_VOP by software.
= 0, ACTIVE
= 1, INACTIVE

PMU_BISR_CON12 = 0x8230 ; Memory repair control register 12
> 15, 1, PD_VOPESMART_INITRSTN_SFTENA ; Configure initial reset for PD_VOPESMART by software.
= 0, ACTIVE
= 1, INACTIVE

> 14, 1, PD_VOPDSC4K_INITRSTN_SFTENA ; Configure initial reset for PD_VOPDSC4K by software.
= 0, ACTIVE
= 1, INACTIVE

> 13, 1, PD_VOPDSC8K_INITRSTN_SFTENA ; Configure initial reset for PD_VOPDSC8K by software.
= 0, ACTIVE
= 1, INACTIVE

> 12, 1, PD_VOPCLUSTER3_INITRSTN_SFTENA ; Configure initial reset for PD_VOPCLUSTER3 by software.
= 0, ACTIVE
= 1, INACTIVE

> 11, 1, PD_VOPCLUSTER2_INITRSTN_SFTENA ; Configure initial reset for PD_VOPCLUSTER2 by software.
= 0, ACTIVE
= 1, INACTIVE

> 10, 1, PD_VOPCLUSTER1_INITRSTN_SFTENA ; Configure initial reset for PD_VOPCLUSTER1 by software.
= 0, ACTIVE
= 1, INACTIVE

> 9, 1, PD_VOPCLUSTER0_INITRSTN_SFTENA ; Configure initial reset for PD_VOPCLUSTER0 by software.
= 0, ACTIVE
= 1, INACTIVE

> 8, 1, PD_CPU0_INITRSTN_SFTENA ; Configure initial reset for PD_CPU0 by software.
= 0, ACTIVE
= 1, INACTIVE

> 7, 1, PD_CPU1_INITRSTN_SFTENA ; Configure initial reset for PD_CPU1 by software.
= 0, ACTIVE
= 1, INACTIVE

> 6, 1, PD_CPU2_INITRSTN_SFTENA ; Configure initial reset for PD_CPU2 by software.
= 0, ACTIVE
= 1, INACTIVE

> 5, 1, PD_CPU3_INITRSTN_SFTENA ; Configure initial reset for PD_CPU3 by software.
= 0, ACTIVE
= 1, INACTIVE

> 4, 1, PD_CPU4_INITRSTN_SFTENA ; Configure initial reset for PD_CPU4 by software.
= 0, ACTIVE
= 1, INACTIVE

> 3, 1, PD_CPU5_INITRSTN_SFTENA ; Configure initial reset for PD_CPU5 by software.
= 0, ACTIVE
= 1, INACTIVE

> 2, 1, PD_CPU6_INITRSTN_SFTENA ; Configure initial reset for PD_CPU6 by software.
= 0, ACTIVE
= 1, INACTIVE

> 1, 1, PD_CPU7_INITRSTN_SFTENA ; Configure initial reset for PD_CPU7 by software.
= 0, ACTIVE
= 1, INACTIVE

> 0, 1, PD_DSU_INITRSTN_SFTENA ; Configure initial reset for PD_DSU by software.
= 0, ACTIVE
= 1, INACTIVE

PMU_BISR_CON13 = 0x8234 ; Memory repair control register 13
> 13, 1, PCIEPHY_INITRSTN_SFTENA ; Configure repair initial reset for PCIEPHY by software.
= 0, ACTIVE
= 1, INACTIVE

> 12, 1, HDMIRXPHY_INITRSTN_SFTENA ; Configure repair initial reset for HDMIRXPHY by software.
= 0, ACTIVE
= 1, INACTIVE

> 9, 1, PCIEPHY_PDGDONE_SFTENA ; Configure repair done for PCIEPHY by software.
= 0, INACTIVE
= 1, ACTIVE

> 8, 1, HDMIRXPHY_PDGDONE_SFTENA ; Configure repair done for HDMIRXPHY by software.
= 0, INACTIVE
= 1, ACTIVE

> 5, 1, PCIEPHY_REPAIR_SFTENA ; Enable memory repair for PCIEPHY by software.
= 0, DISABLE
= 1, ENABLE

> 4, 1, HDMIRXPHY_REPAIR_SFTENA ; Enable memory repair for HDMIRXPHY by software.
= 0, DISABLE
= 1, ENABLE

> 1, 1, PCIEPHY_REPAIR_ENA ; Enable memory repair for PCIEPHY by hardware.
= 0, DISABLE
= 1, ENABLE

> 0, 1, HDMIRXPHY_REPAIR_ENA ; Enable memory repair for HDMIRXPHY by hardware.
= 0, DISABLE
= 1, ENABLE

PMU_BISR_CON14 = 0x8238 ; Memory repair control register 14
> 0, 32, BISR_TIMEOUT_CNT ; BISR timeout count for PDGDone. Number of repair clock used by counter logic.

PMU_BISR_STS0 = 0x8280 ; Memory repair status register 0
> 31, 1, PD_BUS_DWN_PDGDONE, RO ; PDGDone status for PD_BUS repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 30, 1, PD_DDR23_DWN_PDGDONE, RO ; PDGDone status for VD_DDR23 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 29, 1, PD_DDR01_DWN_PDGDONE, RO ; PDGDone status for VD_DDR01 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 28, 1, PD_CENTER_DWN_PDGDONE, RO ; PDGDone status for PD_CENTER repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 27, 1, PD_CRYPTO_DWN_PDGDONE, RO ; PDGDone status for PD_CRYPTO repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 26, 1, PD_SDMMC_DWN_PDGDONE, RO ; PDGDone status for PD_SDMMC repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 25, 1, PD_USB_DWN_PDGDONE, RO ; PDGDone status for PD_USB repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 24, 1, PD_SDIO_DWN_PDGDONE, RO ; PDGDone status for PD_SDIO repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 23, 1, PD_NVM0_DWN_PDGDONE, RO ; PDGDone status for PD_NVM0 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 22, 1, PD_PCIE_DWN_PDGDONE, RO ; PDGDone status for PD_PCIE repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 21, 1, PD_GMAC_DWN_PDGDONE, RO ; PDGDone status for PD_GMAC repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 20, 1, PD_PHP_DWN_PDGDONE, RO ; PDGDone status for PD_PHP repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 19, 1, PD_AUDIO_DWN_PDGDONE, RO ; PDGDone status for PD_AUDIO repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 18, 1, PD_VO1_DWN_PDGDONE, RO ; PDGDone status for PD_VO1 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 17, 1, PD_VO0_DWN_PDGDONE, RO ; PDGDone status for PD_VO0 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 16, 1, PD_VOP_DWN_PDGDONE, RO ; PDGDone status for PD_VOP repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 15, 1, PD_RGA31_DWN_PDGDONE, RO ; PDGDone status for PD_RGA31 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 14, 1, PD_ISP1_DWN_PDGDONE, RO ; PDGDone status for PD_ISP1 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 13, 1, PD_FEC_DWN_PDGDONE, RO ; PDGDone status for PD_FEC repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 12, 1, PD_VI_DWN_PDGDONE, RO ; PDGDone status for PD_VI repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 11, 1, PD_AV1_DWN_PDGDONE, RO ; PDGDone status for PD_AV1 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 10, 1, PD_RGA30_DWN_PDGDONE, RO ; PDGDone status for PD_RGA30 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 9, 1, PD_VDPU_DWN_PDGDONE, RO ; PDGDone status for PD_VDPU repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 8, 1, PD_RKVDEC1_DWN_PDGDONE, RO ; PDGDone status for PD_RKVDEC1 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 7, 1, PD_RKVDEC0_DWN_PDGDONE, RO ; PDGDone status for PD_RKVDEC0 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 6, 1, PD_VENC1_DWN_PDGDONE, RO ; PDGDone status for PD_VENC1 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 5, 1, PD_VENC0_DWN_PDGDONE, RO ; PDGDone status for PD_VENC0 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 4, 1, PD_NPU2_DWN_PDGDONE, RO ; PDGDone status for PD_NPU2 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 3, 1, PD_NPU1_DWN_PDGDONE, RO ; PDGDone status for PD_NPU1 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 2, 1, PD_NPUTOP_DWN_PDGDONE, RO ; PDGDone status for PD_NPUTOP repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 1, 1, PD_GPU_BISR_PDGDONE, RO ; PDGDone status for VD_GPU repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 0, 1, PD_PMU1_REPAIR_PDGDONE, RO ; PDGDone status for PD_PMU1 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

PMU_BISR_STS1 = 0x8284 ; Memory repair status register 1
> 17, 1, PCIEPHY_REPAIR_PDGDONE, RO ; PDGDone status for PCIEPHY repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 16, 1, HDMIRXPHY_REPAIR_PDGDONE, RO ; PDGDone status for HDMIRXPHY repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 15, 1, PD_VOPESMART_REPAIR_PDGDONE, RO ; PDGDone status for PD_VOPESMAKRT repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 14, 1, PD_VOPDSC4K_REPAIR_PDGDONE, RO ; PDGDone status for PD_VOPDSC4K repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 13, 1, PD_VOPDSC8K_REPAIR_PDGDONE, RO ; PDGDone status for PD_VOPDSC8K repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 12, 1, PD_VOPCLUSTER3_REPAIR_PDGDONE, RO ; PDGDone status for PD_VOPCLUSTER3 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 11, 1, PD_VOPCLUSTER2_REPAIR_PDGDONE, RO ; PDGDone status for PD_VOPCLUSTER2 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 10, 1, PD_VOPCLUSTER1_REPAIR_PDGDONE, RO ; PDGDone status for PD_VOPCLUSTER1 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 9, 1, PD_VOPCLUSTER0_REPAIR_PDGDONE, RO ; PDGDone status for PD_VOPCLUSTER0 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 8, 1, PD_CPU0_REPAIR_PDGDONE, RO ; PDGDone status for PD_CPU0 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 7, 1, PD_CPU1_REPAIR_PDGDONE, RO ; PDGDone status for PD_CPU1 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 6, 1, PD_CPU2_REPAIR_PDGDONE, RO ; PDGDone status for PD_CPU3 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 5, 1, PD_CPU3_REPAIR_PDGDONE, RO ; PDGDone status for PD_CPU3 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 4, 1, PD_CPU4_REPAIR_PDGDONE, RO ; PDGDone status for PD_CPU4 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 3, 1, PD_CPU5_REPAIR_PDGDONE, RO ; PDGDone status for PD_CPU5 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 2, 1, PD_CPU6_REPAIR_PDGDONE, RO ; PDGDone status for PD_CPU6 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 1, 1, PD_CPU7_REPAIR_PDGDONE, RO ; PDGDone status for PD_CPU7 repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

> 0, 1, PD_DSU_REPAIR_PDGDONE, RO ; PDGDone status for PD_DSU repair.
= 0, NOT_COMPLETE ; Repair not complete
= 1, COMPLETE ; Repair complete

PMU_BISR_STS2 = 0x8288 ; Memory repair status register 2
> 31, 1, PD_BUS_REPAIR_CEDIS, RO ; CEDis status for PD_BUS repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 30, 1, PD_DDR23_REPAIR_CEDIS, RO ; CEDis status for VD_DDR23 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 29, 1, PD_DDR01_REPAIR_CEDIS, RO ; CEDis status for VD_DDR01 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 28, 1, PD_CENTER_REPAIR_CEDIS, RO ; CEDis status for PD_CENTER repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 27, 1, PD_CRYPTO_REPAIR_CEDIS, RO ; CEDis status for PD_CRYPTO repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 26, 1, PD_SDMMC_REPAIR_CEDIS, RO ; CEDis status for PD_SDMMC repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 25, 1, PD_USB_REPAIR_CEDIS, RO ; CEDis status for PD_USB repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 24, 1, PD_SDIO_REPAIR_CEDIS, RO ; CEDis status for PD_SDIO repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 23, 1, PD_NVM0_REPAIR_CEDIS, RO ; CEDis status for PD_NVM0 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 22, 1, PD_PCIE_REPAIR_CEDIS, RO ; CEDis status for PD_PCIE repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 21, 1, PD_GMAC_REPAIR_CEDIS, RO ; CEDis status for PD_GMAC repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 20, 1, PD_PHP_REPAIR_CEDIS, RO ; CEDis status for PD_PHP repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 19, 1, PD_AUDIO_REPAIR_CEDIS, RO ; CEDis status for PD_AUDIO repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 18, 1, PD_VO1_REPAIR_CEDIS, RO ; CEDis status for PD_VO1 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 17, 1, PD_VO0_REPAIR_CEDIS, RO ; CEDis status for PD_VO0 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 16, 1, PD_VOP_REPAIR_CEDIS, RO ; CEDis status for PD_VOP repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 15, 1, PD_RGA31_REPAIR_CEDIS, RO ; CEDis status for PD_RGA31 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 14, 1, PD_ISP1_REPAIR_CEDIS, RO ; CEDis status for PD_ISP1 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 13, 1, PD_FEC_REPAIR_CEDIS, RO ; CEDis status for PD_FEC repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 12, 1, PD_VI_REPAIR_CEDIS, RO ; CEDis status for PD_VI repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 11, 1, PD_AV1_REPAIR_CEDIS, RO ; CEDis status for PD_AV1 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 10, 1, PD_RGA30_REPAIR_CEDIS, RO ; CEDis status for PD_RGA30 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 9, 1, PD_VDPU_REPAIR_CEDIS, RO ; CEDis status for PD_VDPU repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 8, 1, PD_RKVDEC1_REPAIR_CEDIS, RO ; CEDis status for PD_RKVDEC1 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 7, 1, PD_RKVDEC0_REPAIR_CEDIS, RO ; CEDis status for PD_RKVDEC0 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 6, 1, PD_VENC1_REPAIR_CEDIS, RO ; CEDis status for PD_VENC1 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 5, 1, PD_VENC0_REPAIR_CEDIS, RO ; CEDis status for PD_VENC0 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 4, 1, PD_NPU2_REPAIR_CEDIS, RO ; CEDis status for PD_NPU2 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 3, 1, PD_NPU1_REPAIR_CEDIS, RO ; CEDis status for PD_NPU1 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 2, 1, PD_NPUTOP_REPAIR_CEDIS, RO ; CEDis status for PD_NPUTOP repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 1, 1, PD_GPU_BISR_CEDIS, RO ; CEDis status for VD_GPU repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 0, 1, PD_PMU1_REPAIR_CEDIS, RO ; CEDis status for PD_PMU1 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

PMU_BISR_STS3 = 0x828C ; Memory repair status register 3
> 17, 1, PCIEPHY_REPAIR_CEDIS, RO ; CEDis status for PCIEPHY repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 16, 1, HDMIRXPHY_REPAIR_CEDIS, RO ; CEDis status for HDMIRXPHY repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 15, 1, PD_VOPESMART_REPAIR_CEDIS, RO ; CEDis status for PD_VOPESMAKRT repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 14, 1, PD_VOPDSC4K_REPAIR_CEDIS, RO ; CEDis status for PD_VOPDSC4K repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 13, 1, PD_VOPDSC8K_REPAIR_CEDIS, RO ; CEDis status for PD_VOPDSC8K repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 12, 1, PD_VOPCLUSTER3_REPAIR_CEDIS, RO ; CEDis status for PD_VOPCLUSTER3 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 11, 1, PD_VOPCLUSTER2_REPAIR_CEDIS, RO ; CEDis status for PD_VOPCLUSTER2 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 10, 1, PD_VOPCLUSTER1_REPAIR_CEDIS, RO ; CEDis status for PD_VOPCLUSTER1 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 9, 1, PD_VOPCLUSTER0_REPAIR_CEDIS, RO ; CEDis status for PD_VOPCLUSTER0 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 8, 1, PD_CPU0_REPAIR_CEDIS, RO ; CEDis status for PD_CPU0 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 7, 1, PD_CPU1_REPAIR_CEDIS, RO ; CEDis status for PD_CPU1 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 6, 1, PD_CPU2_REPAIR_CEDIS, RO ; CEDis status for PD_CPU3 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 5, 1, PD_CPU3_REPAIR_CEDIS, RO ; CEDis status for PD_CPU3 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 4, 1, PD_CPU4_REPAIR_CEDIS, RO ; CEDis status for PD_CPU4 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 3, 1, PD_CPU5_REPAIR_CEDIS, RO ; CEDis status for PD_CPU5 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 2, 1, PD_CPU6_REPAIR_CEDIS, RO ; CEDis status for PD_CPU6 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 1, 1, PD_CPU7_REPAIR_CEDIS, RO ; CEDis status for PD_CPU7 repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

> 0, 1, PD_DSU_REPAIR_CEDIS, RO ; CEDis status for PD_DSU repair.
= 0, READY ; Repair ready
= 1, BUSY ; Repair busy

PMU_BISR_STS4 = 0x8290 ; Memory repair status register 4
> 31, 1, PD_BUS_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_BUS repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 30, 1, PD_DDR23_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for VD_DDR23 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 29, 1, PD_DDR01_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for VD_DDR01 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 28, 1, PD_CENTER_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_CENTER repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 27, 1, PD_CRYPTO_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_CRYPTO repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 26, 1, PD_SDMMC_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_SDMMC repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 25, 1, PD_USB_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_USB repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 24, 1, PD_SDIO_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_SDIO repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 23, 1, PD_NVM0_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_NVM0 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 22, 1, PD_PCIE_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_PCIE repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 21, 1, PD_GMAC_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_GMAC repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 20, 1, PD_PHP_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_PHP repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 19, 1, PD_AUDIO_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_AUDIO repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 18, 1, PD_VO1_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VO1 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 17, 1, PD_VO0_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VO0 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 16, 1, PD_VOP_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VOP repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 15, 1, PD_RGA31_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_RGA31 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 14, 1, PD_ISP1_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_ISP1 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 13, 1, PD_FEC_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_FEC repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 12, 1, PD_VI_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VI repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 11, 1, PD_AV1_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_AV1 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 10, 1, PD_RGA30_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_RGA30 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 9, 1, PD_VDPU_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VDPU repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 8, 1, PD_RKVDEC1_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_RKVDEC1 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 7, 1, PD_RKVDEC0_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_RKVDEC0 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 6, 1, PD_VENC1_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VENC1 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 5, 1, PD_VENC0_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VENC0 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 4, 1, PD_NPU2_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_NPU2 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 3, 1, PD_NPU1_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_NPU1 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 2, 1, PD_NPUTOP_DWN_PWR_REPAIR_STAT, RO ; Power and repair status for PD_NPUTOP repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 1, 1, PD_GPU_BISR_PWR_REPAIR_STAT, RO ; Power and repair status for VD_GPU repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 0, 1, PD_PMU1_PWR_REPAIR_STAT, RO ; Power and repair status for PD_PMU1.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

PMU_BISR_STS5 = 0x8294 ; Memory repair status register 5
> 17, 1, PCIEPHY_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PCIEPHY repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 16, 1, HDMIRXPHY_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for HDMIRXPHY repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 15, 1, PD_VOPESMART_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VOPESMAKRT repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 14, 1, PD_VOPDSC4K_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VOPDSC4K repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 13, 1, PD_VOPDSC8K_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VOPDSC8K repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 12, 1, PD_VOPCLUSTER3_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VOPCLUSTER3 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 11, 1, PD_VOPCLUSTER2_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VOPCLUSTER2 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 10, 1, PD_VOPCLUSTER1_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VOPCLUSTER1 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 9, 1, PD_VOPCLUSTER0_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_VOPCLUSTER0 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 8, 1, PD_CPU0_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_CPU0 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 7, 1, PD_CPU1_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_CPU1 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 6, 1, PD_CPU2_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_CPU3 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 5, 1, PD_CPU3_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_CPU3 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 4, 1, PD_CPU4_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_CPU4 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 3, 1, PD_CPU5_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_CPU5 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 2, 1, PD_CPU6_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_CPU6 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 1, 1, PD_CPU7_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_CPU7 repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

> 0, 1, PD_DSU_REPAIR_PWR_REPAIR_STAT, RO ; Power and repair status for PD_DSU repair.
= 0, DOWN_OR_INCOMPLETE ; Power down or repair not complete
= 1, UP_AND_COMPLETE ; Power up and repair complete

